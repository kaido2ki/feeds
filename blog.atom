<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>方寸之間</title><description>居善地 心善淵</description><link>https://smj.im/</link><item><title>修复Arch Linux的内核缺失问题</title><link>https://smj.im/blag/posts/repair-archlinux-kernel/</link><guid isPermaLink="true">https://smj.im/blag/posts/repair-archlinux-kernel/</guid><description>Arch Linux系统启动进入grub界面，提示vmlinuz-zen not found，这里记录一下解决方案</description><pubDate>Sun, 20 Aug 2023 01:20:07 GMT</pubDate><content:encoded>&lt;h2&gt;起因&lt;/h2&gt;
&lt;p&gt;早上打开电脑，Terminal 久违地更新一下系统，因为太久没更新，很多要更新的包，所以更新的时候打开浏览器去做别的事了，结果还没看两分钟，电脑突然黑屏了。。。什么反应都没有，但是能听到电脑还在转，也没多想，我就直接强制关机了。结果，再启动电脑，进入 grub 界面，直接不动了（一般默认 5s 自动选择），手动选择，提示：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Loading kernel linux-zen
error: file &apos;/boot/vmlinuz-linux-zen&apos; not found
Loading initial ramdisk
error: you need to load the kernel first
Press any key to continue...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;猜测应该是因为更新内核的时候电脑被强制关机导致内核出问题了。在 Arch Linux BBS 上找到了一些解决方案，这里记录一下。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;我使用的是&lt;code&gt;linux-zen&lt;/code&gt;内核，所以后面的相关内容都有&lt;code&gt;-zen&lt;/code&gt;后缀，这个根据你自己的配置更改，一般安装的都是&lt;code&gt;linux&lt;/code&gt;内核，去掉&lt;code&gt;-zen&lt;/code&gt;后缀即可。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;解决方案&lt;/h2&gt;
&lt;h3&gt;使用 Arch Linux 安装介质&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;进入 live 环境后，连接网络，我用的是 iwd&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;[root@archiso]# iwctl
[iwd]# station wlan0 connect wifi-ssid # 连接指定Wi-Fi
[iwd]# station wlan0 show # 确认是否连接成功
[iwd]# exit
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;挂载&lt;code&gt;/&lt;/code&gt;和&lt;code&gt;boot&lt;/code&gt;分区&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;mount /dev/sdaX /mnt
mount /dev/sdaY /mnt/boot
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;chroot 系统，重新安装内核&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;arch-chroot /mnt
pacman -S linux-zen
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;重新生成 grub 引导&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;grub-mkconfig -o /boot/grub/grug.cfg
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;取消挂载分区，重启&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;exit
umount -R /mnt
reboot
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;启动之后，就可以正常进入系统了。&lt;/p&gt;
&lt;h3&gt;grub 命令行&lt;/h3&gt;
&lt;p&gt;这个方法和上面的类似，不过不用使用安装介质&lt;/p&gt;
&lt;h4&gt;确认&lt;code&gt;/&lt;/code&gt;分区位置&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;使用&lt;code&gt;ls&lt;/code&gt;列出电脑上所有硬盘，输出类似：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;grub&amp;gt;ls
(hd0) (hd0, gpt1) ...... (hd1, gpt4)
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;确认&lt;code&gt;/&lt;/code&gt;分区，可以使用&lt;code&gt;cat&lt;/code&gt;/&lt;code&gt;ls&lt;/code&gt;命令+&lt;code&gt;Tab&lt;/code&gt;测试，例如：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;grub&amp;gt;ls (hd0,gpt3)/ TAB
boot usr ....
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面的输出说明&lt;code&gt;(hd0,gpt3)&lt;/code&gt;是 &lt;code&gt;/&lt;/code&gt; 分区。&lt;/p&gt;
&lt;h4&gt;手动加载内核&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;设置根分区和 grub 路径前缀
假设&lt;code&gt;(hd0,gpt3)&lt;/code&gt;是根分区：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;grub&amp;gt;set root=(hd0,gpt3)
grub&amp;gt;set prefix=(hd0,gpt3)/boot/grub
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;加载内核和系统镜像&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;grub&amp;gt;cat (hd0,gpt3)/boot/grub/grub.cfg #确认`/`分区的设备名称，假设是`/dev/sda3`
grub&amp;gt;linux /boot/vmlinuz-linux-zen root=/dev/sda3
grub&amp;gt;initrd /boot/initrd-linux-zen.img
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;启动系统&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;grub&amp;gt;boot
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;重新配置 grub
启动之后，按照&lt;a href=&quot;#%E4%BD%BF%E7%94%A8arch-linux%E5%AE%89%E8%A3%85%E4%BB%8B%E8%B4%A8&quot;&gt;第一种方法&lt;/a&gt;的第 2、4、5 步，在命令行下重新生成一下 grub.cfg 文件即可。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;参考链接&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://bbs.archlinux.org/viewtopic.php?id=274616&quot;&gt;https://bbs.archlinux.org/viewtopic.php?id=274616&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://wiki.archlinux.org/title/GRUB#Using_the_command_shell&quot;&gt;https://wiki.archlinux.org/title/GRUB#Using_the_command_shell&lt;/a&gt;&lt;/p&gt;
</content:encoded></item><item><title>安装定制化Vim</title><link>https://smj.im/blag/posts/build-vim-from-source/</link><guid isPermaLink="true">https://smj.im/blag/posts/build-vim-from-source/</guid><description>为了使用带有剪切板功能的Vim，我尝试了很多方法，最后发现，还是源码构建最好用</description><pubDate>Thu, 10 Aug 2023 08:07:52 GMT</pubDate><content:encoded>&lt;p&gt;以前在使用 Vim 编写代码的时候就发现，Vim
yank 的内容无法直接进入系统剪切板，稍微 Google 了以下发现好像需要使用第三方软件（Linux 上的 xclip 或者 MacOS 上的 pbcopy），懒得折腾，就新开一个 Terminal，然后 cat 出来文件内容，拷贝需要的内容然后使用（没想到吧;D）。&lt;/p&gt;
&lt;p&gt;最近在折腾 Vim 环境的时候，又发现了这个问题，这下不能忍了，所以索性找找有没有简单的解决方法。最后勉强找到了几个我认为比较简单的解决方法。&lt;/p&gt;
&lt;h2&gt;0. 确认是否带有剪切板特性&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;vim --version | grep clipboard
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果输出&lt;code&gt;+clipboard&lt;/code&gt;代表有剪切板特性，恭喜你，可以直接下拉进入文末；如果出现&lt;code&gt;-clipboard&lt;/code&gt;则说明没有，那你可以接着往下看。&lt;/p&gt;
&lt;h2&gt;1. 使用 gvim&lt;/h2&gt;
&lt;p&gt;直接安装 gvim，带有命令行版本的 Vim 是支持剪切板特性的。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo pacman -S gvim
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;2. 使用 Arch Linux 社区的第三方源仓库&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;鲁迅曾说：遇事不决，上 Arch wiki。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;官方 wiki 的 Vim 界面提到了一个 Unofficial Repository
&lt;code&gt;herecura&lt;/code&gt;，这是一个个人维护的源仓库，里面是一些个人编译的 Linux 软件。&lt;/p&gt;
&lt;p&gt;将以下内容加入&lt;code&gt;/etc/pacman.conf&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[herecura]
Server = https://repo.herecura.eu/$repo/$arch
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后安装&lt;code&gt;vim-cli&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo pacman -Syu
sudo pacman -S vim-cli
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;3. AUR 安装&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如果你对 AUR 了解比较多，可以尝试自己构建 PKGBUILD 文件。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果不了解也没关系，我们可以直接找现成的。可以选择直接修改 Arch Linux 官方的 PKGBUILD，在这基础上加入 clipboard 功能支持。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;i. 克隆官方的 Vim 包构建仓库：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git clone https://gitlab.archlinux.org/archlinux/packaging/packages/vim.git
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ii. 修改&lt;code&gt;PKGBUILD&lt;/code&gt;文件，修改&lt;code&gt;--with-x&lt;/code&gt;为&lt;code&gt;yes&lt;/code&gt;，为了节省时间，可以去掉 gvim 的构建。&lt;/p&gt;
&lt;p&gt;&amp;lt;details&amp;gt;
&amp;lt;summary&amp;gt;点击这里查看修改后的&lt;code&gt;PKGBUILD&lt;/code&gt;内容&amp;lt;/summary&amp;gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://pb.oii.im/R66p&quot;&gt;点击这里复制&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;pkgbase=vim
pkgname=(&apos;vim&apos; &apos;vim-runtime&apos;)
pkgver=9.0.1678
_versiondir=90
pkgrel=1
pkgdesc=&apos;Vi Improved, a highly configurable, improved version of the vi text editor&apos;
url=&apos;https://www.vim.org&apos;
arch=(&apos;x86_64&apos; &apos;x86_64_v3&apos;)
license=(&apos;custom:vim&apos;)
makedepends=(&apos;glibc&apos; &apos;libgcrypt&apos; &apos;gpm&apos; &apos;python&apos; &apos;ruby&apos; &apos;libxt&apos; &apos;gtk3&apos; &apos;lua&apos;
             &apos;gawk&apos; &apos;tcl&apos; &apos;zlib&apos; &apos;libcanberra&apos;)
source=(https://github.com/vim/vim/archive/v${pkgver}/${pkgbase}-${pkgver}.tar.gz fix-perl-build.patch
        vimrc
        archlinux.vim
        vimdoc.hook)
sha256sums=(&apos;e0b52a997b4f6180c5d8a5dae717075d99650c3e2e7761d1878a3dd7011ec315&apos;
            &apos;f79c2afd26bbe0b21375293203d8f0e8dad2424146014ceafc4e8eca6ecf7d39&apos;
            &apos;b16e85e457397ab2043a7ee0a3c84307c6b4eac157fd0b721694761f25b3ed5b&apos;
            &apos;cc3d931129854c298eb22e993ec14c2ad86cc1e70a08a64496f5e06559289972&apos;
            &apos;8e9656934d9d7793063230d15a689e10455e6db9b9fe73afa0f294792795d8ae&apos;)
sha512sums=(&apos;c5ffb7ca56ff4eee70f06599dd84db2eb28ddadac229d4f7faf01174805923636a4ce61486bdf5a47910c929613dc9b9290dfc9288006222b4bc4ac891548bb8&apos;
            &apos;184dd232db5b4a346e9751e58ad0a9b2f60d50d1a2aa2050415d288445606d80c239745f0d8987ff822d2acf6826104a81f8e59c8f1785095d1f319c0fe4abf0&apos;
            &apos;4b5bed0813f22af9e158ea9aa56a4a9862dd786ba2d201f20159ccf652da6190164aaed0b6b7217d578f7b25c33a8adcc307bfcf3caa8d173a7ff29e2a00fee7&apos;
            &apos;fe091d289d876f45319c898f6021ef86d6a238b540c225a279c46efc5c36fa7d868cd0cee73a111811c4be90df160f85340bb251be3a437727dbe5c699950363&apos;
            &apos;a02ad0d66f300160911aeb81d8886c6c558436ac4ee3fcd161dd65c6b1e5d1f41b9005a7f5bb5ba68d57027fc1c8e43daabf055bd6207fb5a216a67f758df8d1&apos;)

prepare() {
  (cd vim-${pkgver}/src
    patch -Np2 -i ../../fix-perl-build.patch
    # define the place for the global (g)vimrc file (set to /etc/vimrc)
    sed -E &apos;s|^.*(#define SYS_.*VIMRC_FILE.*&quot;).*$|\1|g&apos; -i feature.h
    sed -E &apos;s|^.*(#define VIMRC_FILE.*&quot;).*$|\1|g&apos; -i feature.h
    autoconf
  )
  cp -a vim-${pkgver} gvim-${pkgver}
}

build() {
  echo &quot;Building vim...&quot;
  (cd vim-${pkgver}
    ./configure \
      --prefix=/usr \
      --localstatedir=/var/lib/vim \
      --with-features=huge \
      --with-compiledby=&apos;Arch Linux&apos; \
      --enable-gpm \
      --enable-acl \
      --with-x=yes \ # 这里改为yes
      --disable-gui \
      --enable-multibyte \
      --enable-cscope \
      --enable-netbeans \
      --enable-perlinterp=dynamic \
      --enable-python3interp=dynamic \
      --enable-rubyinterp=dynamic \
      --enable-luainterp=dynamic \
      --enable-tclinterp=dynamic \
      --disable-canberra
    make
  )
}

check() {
  cd vim-${pkgver}
  TERM=xterm make -j1 test
}

package_vim-runtime() {
  pkgdesc+=&apos; (shared runtime)&apos;
  optdepends=(&apos;sh: support for some tools and macros&apos;
              &apos;python: demoserver example tool&apos;
              &apos;gawk: mve tools upport&apos;)
  backup=(&apos;etc/vimrc&apos;)

  cd vim-${pkgver}

  make -j1 VIMRCLOC=/etc DESTDIR=&quot;${pkgdir}&quot; install
  # man and bin files belong to &apos;vim&apos;
  rm -r &quot;${pkgdir}&quot;/usr/share/man/ &quot;${pkgdir}&quot;/usr/bin/

  # Don&apos;t forget logtalk.dict
  install -Dm 644 runtime/ftplugin/logtalk.dict \
    &quot;${pkgdir}&quot;/usr/share/vim/vim${_versiondir}/ftplugin/logtalk.dict

  # rc files
  install -Dm 644 &quot;${srcdir}&quot;/vimrc &quot;${pkgdir}&quot;/etc/vimrc
  install -Dm 644 &quot;${srcdir}&quot;/archlinux.vim \
    &quot;${pkgdir}&quot;/usr/share/vim/vimfiles/archlinux.vim

  # no desktop files and icons
  rm -r &quot;${pkgdir}&quot;/usr/share/{applications,icons}

  # license
  install -dm 755 &quot;${pkgdir}&quot;/usr/share/licenses/vim-runtime
  ln -s /usr/share/vim/vim${_versiondir}/doc/uganda.txt \
    &quot;${pkgdir}&quot;/usr/share/licenses/vim-runtime/license.txt

  # pacman hook for documentation helptags
  install -Dm 644 &quot;${srcdir}&quot;/vimdoc.hook &quot;${pkgdir}&quot;/usr/share/libalpm/hooks/vimdoc.hook
}

package_vim() {
  # TODO: move perl back into optdeps after --enable-perlinterp=dynamic
  #       starts working again (https://github.com/vim/vim/issues/10512)
  depends=(&quot;vim-runtime=${pkgver}-${pkgrel}&quot; &apos;gpm&apos; &apos;acl&apos; &apos;glibc&apos; &apos;libgcrypt&apos; &apos;zlib&apos; &apos;perl&apos;)
  optdepends=(&apos;python: Python language support&apos;
              &apos;ruby: Ruby language support&apos;
              &apos;lua: Lua language support&apos;
              #&apos;perl: Perl language support&apos;
              &apos;tcl: Tcl language support&apos;)
  conflicts=(&apos;gvim&apos; &apos;vim-minimal&apos;)
  provides=(&apos;xxd&apos; &apos;vim-minimal&apos; &apos;vim-plugin-runtime&apos;)
  replaces=(&apos;vim-minimal&apos;)

  cd vim-${pkgver}
  make -j1 VIMRCLOC=/etc DESTDIR=&quot;${pkgdir}&quot; install

  # provided by (n)vi in core
  rm &quot;${pkgdir}&quot;/usr/bin/{ex,view}

  # delete some manpages
  find &quot;${pkgdir}&quot;/usr/share/man -type d -name &apos;man1&apos; 2&amp;gt;/dev/null | \
    while read _mandir; do
    cd &quot;${_mandir}&quot;
    rm -f ex.1 view.1 # provided by (n)vi
    rm -f evim.1    # this does not make sense if we have no GUI
  done

  # Runtime provided by runtime package
  rm -r &quot;${pkgdir}&quot;/usr/share/vim

  # remove gvim.desktop as not included
  rm &quot;${pkgdir}&quot;/usr/share/applications/gvim.desktop

  # license
  install -Dm 644 runtime/doc/uganda.txt \
    &quot;${pkgdir}&quot;/usr/share/licenses/${pkgname}/license.txt
}
# vim: ts=2 sw=2 et:
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&amp;lt;/details&amp;gt;&lt;/p&gt;
&lt;p&gt;iii. 构建并安装：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;makepkg -si
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;4. 源码安装&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;安装依赖&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;sudo pacman -S glibc libgcrypt gpm python ruby libxt gtk3 lua gawk tcl zlib gettext pkgconfig
# 需要音频支持的，安装这个依赖
sudo pacman -S libcanberra
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;克隆源码&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;git clone https://github.com/vim/vim.git
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;配置&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;./configure --prefix=/usr --localstatedir=/var/lib/vim \
        --with-features=huge --enable-gpm --enable-acl --with-x=yes \
        --disable-gui --enable-multibyte --enable-cscope \
        --disable-netbeans --enable-perlinterp=dynamic \
        --enable-python3interp=dynamic --enable-rubyinterp=dynamic \
        --enable-luainterp=dynamic --mandir=/usr/share/man
        #################### 需要音频支持的加入以下配置：
        --enable--canberra
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;编译生成&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;# 默认生成
make

# 测试
make test

# 添加额外配置
make reconfig

# 测试
make test

# 安装
sudo make install
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;5. 测试&lt;/h2&gt;
&lt;p&gt;查看 patch 版本及是否包含 clipboard 特性&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ vim --version | grep patch
Included patches: 1-1683

$ vim --version | grep clipboard
+clipboard         +keymap            +printer           +vertsplit
+eval              -mouse_jsbterm     -sun_workshop      +xterm_clipboard
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;6. 参考链接&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/vim/vim&quot;&gt;https://github.com/vim/vim&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/ycm-core/YouCompleteMe/wiki/Building-Vim-from-source&quot;&gt;https://github.com/ycm-core/YouCompleteMe/wiki/Building-Vim-from-source&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://gitlab.archlinux.org/archlinux/packaging/packages/vim/-/blob/main/PKGBUILD&quot;&gt;https://gitlab.archlinux.org/archlinux/packaging/packages/vim/-/blob/main/PKGBUILD&lt;/a&gt;&lt;/p&gt;
</content:encoded></item><item><title>树莓派配置旁路由过程记录</title><link>https://smj.im/blag/posts/raspberrypi-setup-openwrt-guide/</link><guid isPermaLink="true">https://smj.im/blag/posts/raspberrypi-setup-openwrt-guide/</guid><description>树莓派安装配置OpenWrt，并设置作为旁路由网关的记录</description><pubDate>Fri, 04 Aug 2023 23:12:03 GMT</pubDate><content:encoded>&lt;h2&gt;引言&lt;/h2&gt;
&lt;p&gt;&lt;s&gt;树莓派是一款功能强大的微型计算机，广泛应用于物联网、嵌入式系统等领域。除了作为单独的计算设备使用外，树莓派还可以通过配置为旁路由，实现局域网内的网络管理和控制。&lt;/s&gt;&lt;/p&gt;
&lt;p&gt;又翻出来一台吃灰的树莓派，不知道做什么了，想试着做做旁路由,感受一下不一样的上网体验~。&lt;/p&gt;
&lt;h2&gt;准备工作&lt;/h2&gt;
&lt;p&gt;在开始配置旁路由之前，你需要准备以下材料和环境：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一台树莓派（我用的是树莓派 4B）&lt;/li&gt;
&lt;li&gt;一张 SD 卡（越大越好）&lt;/li&gt;
&lt;li&gt;一根网线&lt;/li&gt;
&lt;li&gt;一台电脑（用于配置树莓派）&lt;/li&gt;
&lt;li&gt;一个可用的无线网络&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;烧录固件&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;下载固件：我使用的是开源版的&lt;a href=&quot;https://github.com/immortalwrt/immortalwrt&quot;&gt;&lt;code&gt;immortalwrt&lt;/code&gt;&lt;/a&gt;，从以下地址下载自编译的 openwrt 的固件：
&lt;a href=&quot;https://downloads.immortalwrt.org/releases/21.02.6/targets/bcm27xx/bcm2711/immortalwrt-21.02.6-bcm27xx-bcm2711-rpi-4-ext4-factory.img.gz&quot;&gt;https://downloads.immortalwrt.org/releases/21.02.6/targets/bcm27xx/bcm2711/immortalwrt-21.02.6-bcm27xx-bcm2711-rpi-4-ext4-factory.img.gz&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;https://pichost.netlify.app/blog/65603815d5e67.webp&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;烧录固件：使用烧录工具将固件写入 SD 卡，推荐使用&lt;a href=&quot;https://etcher.balena.io/#download-etcher&quot;&gt;balenaEtcher&lt;/a&gt;（UI 美观）或者 &lt;a href=&quot;https://rufus.ie/en/&quot;&gt;rufus&lt;/a&gt;（轻量简洁），二者均开源免费。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;连接树莓派&lt;/h2&gt;
&lt;p&gt;有两种方式连接树莓派：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用电脑打开默认 UI 网页：http://192.168.1.1， 默认账户为：root，密码为：password，登陆后建议修改默认账户密码（有提示指引）。&lt;/li&gt;
&lt;li&gt;通过 SSH 进入，&lt;code&gt;ssh root@192.168.1.1&lt;/code&gt;连接到树莓派命令行终端。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;修改 LAN 口参数&lt;/h2&gt;
&lt;p&gt;为了实现旁路由的功能，我们需要把树莓派的 LAN 口的 IP 地址改为静态地址。对于静态 IP 的选择，我们需要知道上级路由器的 IP 子网，这个可以登录到路由器后台查看，或者查看连接到路由器的其他设备（如手机）的 IP 地址。
我的上级路由器 IP 为：192.168.0.1，那么子网范围就是 192.168.0.[1~255]，我们可以任意设置一个 2-255 的 IP，但是前提是该 IP 未被分配出去，你可以通过&lt;code&gt;ping&lt;/code&gt;IP 来查看是否存在，如果提示&lt;code&gt;Destination host unreachable.&lt;/code&gt;，说明该 IP 不存在，可以使用。当然，你也可以使用其他 IP 扫描工具来测试。&lt;/p&gt;
&lt;p&gt;这里我们使用 192.168.0.123 作为树莓派的静态 IP 地址。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&amp;lt;details&amp;gt;
&amp;lt;summary&amp;gt;更简单的配置方法&amp;lt;/summary&amp;gt;&lt;/p&gt;
&lt;p&gt;配置完之后，动了动脑子，感觉这两步可以何在一起直接在配置文件中修改，或者在 OpenWrt 控制台的&lt;code&gt;网络-&amp;gt;接口-&amp;gt;LAN&lt;/code&gt;中修改。虽然我没试过（累了不想动了），但是我验证了配置文件，我觉得没毛病。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;🚨 以下均为合理推测 xD🚨&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;details&amp;gt;
&amp;lt;summary&amp;gt;方法1：直接修改网络配置文件&amp;lt;/summary&amp;gt;
网络配置文件位于&lt;code&gt;/etc/config/network&lt;/code&gt;路径下，可以使用文本编辑器（如vi或nano）进行编辑。&lt;/p&gt;
&lt;p&gt;首先，使用以下命令进入网络配置文件：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;vi /etc/config/network
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后，更改 LAN 接口的 IP 地址，你可以在配置文件中找到以下行：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;config interface &apos;lan&apos;
        option ipaddr &apos;192.168.1.1&apos;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;将&lt;code&gt;config interface &apos;lan&apos;&lt;/code&gt;的值更改为我们需要的配置参数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;config interface &apos;lan&apos;
        option type &apos;bridge&apos;
        option ifname &apos;eth0&apos;
        option proto &apos;static&apos;
        option netmask &apos;255.255.255.0&apos;
        option ip6assign &apos;60&apos;
        option ipaddr &apos;192.168.0.123&apos;
        option gateway &apos;192.168.0.1&apos;
        option broadcast &apos;192.168.0.255&apos;
        option dns &apos;192.168.0.1&apos;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;保存并退出文件。&lt;/p&gt;
&lt;p&gt;接下来，重新启动网络服务以使更改生效：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/etc/init.d/network restart
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&amp;lt;/details&amp;gt;
&amp;lt;br/&amp;gt;
&amp;lt;details&amp;gt;
&amp;lt;summary&amp;gt;方法2：直接在OpenWrt控制界面修改&amp;lt;/summary&amp;gt;&lt;/p&gt;
&lt;p&gt;修改设置参数如下：
&lt;img src=&quot;https://pichost.netlify.app/blog/656037e61ff15.webp&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;/details&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;/details&amp;gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;以下我配置的时候，参考的方法：&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;修改 IP 地址&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;如果你是使用网页连接的树莓派，可以从&lt;code&gt;系统-&amp;gt;TTYD终端&lt;/code&gt;页面进入树莓派的命令行。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在命令行终端输入一下命令：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;uci set network.lan.ipaddr=192.168.0.123
uci commit network
/etc/init.d/network restart
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;修改网关及 DNS&lt;/h3&gt;
&lt;p&gt;修改好 IP 地址之后，我们需要修改一些其他的 IP 参数来保证网络的正常运行。&lt;/p&gt;
&lt;p&gt;断开并重连电脑与树莓派的连接，如果搜不到树莓派的 WiFi 网络，树莓派重启一下应该就好了（我配置的时候用的 win10，断开之后就检测不到了，重启下就好了，不知道是我的原因还是系统原因。。。）。&lt;/p&gt;
&lt;p&gt;浏览器打开 OpenWrt 的界面（http://192.168.0.123），输入默认账户root，密码password，进入web界面后，先根据指引修改登录的账户密码。&lt;/p&gt;
&lt;p&gt;首先，进入&lt;code&gt;网络-&amp;gt;接口&lt;/code&gt;页面，选中修改&lt;code&gt;LAN&lt;/code&gt;接口:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;传输协议：静态地址

IPV4 地址：192.168.0.123

IPV4 子网掩码: 255.255.255.0

IPV4 网关：192.168.0.1 （上级路由IP）

IPV4 广播：192.168.0.255 （把上级路由 IP 最后一段改为 255）

DNS 地址：192.168.0.1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后，勾选下方基本设置中的&lt;code&gt;忽略此接口&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&amp;lt;details&amp;gt;
&amp;lt;summary&amp;gt;查看图片说明&amp;lt;/summary&amp;gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pichost.netlify.app/blog/656037e61ff15.webp&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;/details&amp;gt;&lt;/p&gt;
&lt;p&gt;最后，点击&lt;code&gt;保存&amp;amp;应用&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;到这一步，树莓派的内部配置基本已经完成，接下来我们断开电脑与树莓派的连接，将树莓派的网口接入上级路由器的 LAN 口即可，为了保证正常工作，可以手动重启一下树莓派。&lt;/p&gt;
&lt;h2&gt;客户端配置&lt;/h2&gt;
&lt;p&gt;然后是客户端的配置，对于每一个需要使用旁路由的设备，我们都需要修改为静态 IP 地址，分配一个路由器子网内的 IP 即可，以上文 IP 网段为例，我们可以使用&lt;code&gt;192.168.0.199&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;我们以设置 Windows11 连接到旁路由为例，&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;IPV4 地址：192.168.0.199

IPV4 子网掩码: 255.255.255.0

IPV4 网关：192.168.0.123 （树莓派IP）

DNS 服务器：192.168.0.123 （树莓派IP）
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&amp;lt;details&amp;gt;
&amp;lt;summary&amp;gt;查看配置图片说明&amp;lt;/summary&amp;gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Win 11&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://pichost.netlify.app/blog/65603a6a3de89.webp&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;/details&amp;gt;&lt;/p&gt;
&lt;p&gt;设置保存之后，我们来验证一下是否成功，打开&lt;code&gt;cmd&lt;/code&gt;输入&lt;code&gt;ipconfig&lt;/code&gt;,查看 WiFi 网卡的基本信息，如果输入类似以下内容，代表静态 IP 配置成功：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Wireless LAN adapter Wi-Fi:

   Connection-specific DNS Suffix  . :
   Link-local IPv6 Address . . . . . : fe80::687b:87f3:b17b:5c1%19
   IPv4 Address. . . . . . . . . . . : 192.168.0.199
   Subnet Mask . . . . . . . . . . . : 255.255.255.0
   Default Gateway . . . . . . . . . : 192.168.0.123  #主要是这里
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以防万一，我们打开浏览器，访问一个网站，如果能够正常打开，说明配置成功。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;以上，使用树莓派作为旁路由的基本流程就结束了，之后你可以根据自己的需求去定制各种功能，当然，我使用的这个&lt;code&gt;immoralwrt&lt;/code&gt;，里面已经内置了很多功能（&lt;strong&gt;有魔法，dddd&lt;/strong&gt;），你可以自由开启关闭。&lt;/p&gt;
&lt;p&gt;版本不同可能初始项不同，但是都可以在软件包(&lt;code&gt;系统-&amp;gt;软件包&lt;/code&gt;)中/手动下载安装.&lt;/p&gt;
&lt;p&gt;&amp;lt;details&amp;gt;
&amp;lt;summary&amp;gt;├── 状态&amp;lt;/summary&amp;gt;
│  ├── 概况&amp;lt;br/&amp;gt;
│  ├── 防火墙&amp;lt;br/&amp;gt;
│  ├── 路由表&amp;lt;br/&amp;gt;
│  ├── 系统日志&amp;lt;br/&amp;gt;
│  ├── 内核日志&amp;lt;br/&amp;gt;
│  ├── 系统进程&amp;lt;br/&amp;gt;
│  ├── 实时信息&amp;lt;br/&amp;gt;
│  ├── 实时监控&amp;lt;br/&amp;gt;
│  ├── WireGuard 状态&amp;lt;br/&amp;gt;
│  ├── Online User&amp;lt;br/&amp;gt;
│  ├── 负载均衡&amp;lt;br/&amp;gt;
│  └── 释放内存&amp;lt;br/&amp;gt;
&amp;lt;/details&amp;gt;
&amp;lt;br/&amp;gt;
&amp;lt;details&amp;gt;
&amp;lt;summary&amp;gt;├── 系统&amp;lt;/summary&amp;gt;
│  ├── Web 管理&amp;lt;br/&amp;gt;
│  ├── 系统&amp;lt;br/&amp;gt;
│  ├── 管理权&amp;lt;br/&amp;gt;
│  ├── 软件包&amp;lt;br/&amp;gt;
│  ├── TTYD 终端&amp;lt;br/&amp;gt;
│  ├── 启动项&amp;lt;br/&amp;gt;
│  ├── 计划任务&amp;lt;br/&amp;gt;
│  ├── 挂载点&amp;lt;br/&amp;gt;
│  ├── 磁盘管理&amp;lt;br/&amp;gt;
│  ├── LED 配置&amp;lt;br/&amp;gt;
│  ├── 备份 / 升级&amp;lt;br/&amp;gt;
│  ├── 自定义命令&amp;lt;br/&amp;gt;
│  ├── 定时重启&amp;lt;br/&amp;gt;
│  ├── 文件传输&amp;lt;br/&amp;gt;
│  ├── Argon 主题设置&amp;lt;br/&amp;gt;
│  └── 重启&amp;lt;br/&amp;gt;
&amp;lt;/details&amp;gt;
&amp;lt;br/&amp;gt;
&amp;lt;details&amp;gt;
&amp;lt;summary&amp;gt;├── 服务&amp;lt;/summary&amp;gt;
│  ├── PassWall&amp;lt;br/&amp;gt;
│  ├── AdGuard Home&amp;lt;br/&amp;gt;
│  ├── 上网时间控制&amp;lt;br/&amp;gt;
│  ├── 微信推送&amp;lt;br/&amp;gt;
│  ├── Adblock&amp;lt;br/&amp;gt;
│  ├── OpenClash&amp;lt;br/&amp;gt;
│  ├── 动态 DNS&amp;lt;br/&amp;gt;
│  ├── WiFi 计划&amp;lt;br/&amp;gt;
│  ├── SmartDNS&amp;lt;br/&amp;gt;
│  ├── WatchCat&amp;lt;br/&amp;gt;
│  ├── 网络唤醒&amp;lt;br/&amp;gt;
│  ├── Tinyproxy&amp;lt;br/&amp;gt;
│  ├── UPnP&amp;lt;br/&amp;gt;
│  ├── KMS 服务器&amp;lt;br/&amp;gt;
│  ├── Shairplay&amp;lt;br/&amp;gt;
│  ├── Frps&amp;lt;br/&amp;gt;
│  ├── Nps 内网穿透&amp;lt;br/&amp;gt;
│  ├── Frp 内网穿透&amp;lt;br/&amp;gt;
&amp;lt;/details&amp;gt;
&amp;lt;br/&amp;gt;
&amp;lt;details&amp;gt;
&amp;lt;summary&amp;gt;├── 网络存储&amp;lt;/summary&amp;gt;
│  ├── 文件助手&amp;lt;br/&amp;gt;
│  ├── 文件浏览器&amp;lt;br/&amp;gt;
│  ├── NFS 管理&amp;lt;br/&amp;gt;
│  ├── 储存同步&amp;lt;br/&amp;gt;
│  ├── FTP 服务器&amp;lt;br/&amp;gt;
│  ├── 网络共享&amp;lt;br/&amp;gt;
│  ├── Aria2 配置&amp;lt;br/&amp;gt;
│  ├── Transmission&amp;lt;br/&amp;gt;
│  ├── PCHiFi 数字转盘遥控&amp;lt;br/&amp;gt;
│  ├── 挂载 SMB 网络共享&amp;lt;br/&amp;gt;
│  ├── MJPG-streamer&amp;lt;br/&amp;gt;
│  ├── Rclone&amp;lt;br/&amp;gt;
│  └── BaiduPCS Web&amp;lt;br/&amp;gt;
&amp;lt;/details&amp;gt;
&amp;lt;br/&amp;gt;
&amp;lt;details&amp;gt;
&amp;lt;summary&amp;gt;├── VPN&amp;lt;/summary&amp;gt;
│  ├── PPTP VPN 服务器&amp;lt;br/&amp;gt;
│  ├── IPSec VPN 服务器&amp;lt;br/&amp;gt;
│  ├── OpenVPN 服务器&amp;lt;br/&amp;gt;
│  └── ZeroTier&amp;lt;br/&amp;gt;
&amp;lt;/details&amp;gt;
&amp;lt;br/&amp;gt;
&amp;lt;details&amp;gt;
&amp;lt;summary&amp;gt;├── 网络&amp;lt;/summary&amp;gt;
│  ├── 接口&amp;lt;br/&amp;gt;
│  ├── 无线&amp;lt;br/&amp;gt;
│  ├── 访客网络&amp;lt;br/&amp;gt;
│  ├── DHCP/DNS&amp;lt;br/&amp;gt;
│  ├── 主机名&amp;lt;br/&amp;gt;
│  ├── IP/MAC 绑定&amp;lt;br/&amp;gt;
│  ├── 静态路由&amp;lt;br/&amp;gt;
│  ├── 防火墙&amp;lt;br/&amp;gt;
│  ├── 诊断&amp;lt;br/&amp;gt;
│  ├── SQM QoS&amp;lt;br/&amp;gt;
│  ├── UDP 工具&amp;lt;br/&amp;gt;
│  ├── Socat&amp;lt;br/&amp;gt;
│  ├── 负载均衡&amp;lt;br/&amp;gt;
│  └── Turbo ACC 网络加速&amp;lt;br/&amp;gt;
&amp;lt;/details&amp;gt;
&amp;lt;br/&amp;gt;
&amp;lt;details&amp;gt;
&amp;lt;summary&amp;gt;├── 带宽监控&amp;lt;/summary&amp;gt;
│  ├── 显示&amp;lt;br/&amp;gt;
│  ├── 配置&amp;lt;br/&amp;gt;
│  ├── 备份&amp;lt;br/&amp;gt;
│  └── 实时流量监测&amp;lt;br/&amp;gt;
&amp;lt;/details&amp;gt;&lt;/p&gt;
&lt;p&gt;└── 退出&lt;/p&gt;
&lt;h2&gt;参考资料&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://doc.openwrt.cc&quot;&gt;https://doc.openwrt.cc&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/immortalwrt/immortalwrt&quot;&gt;https://github.com/immortalwrt/immortalwrt&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/SuLingGG/OpenWrt-Rpi/wiki/&quot;&gt;https://github.com/SuLingGG/OpenWrt-Rpi/wiki&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://linux-command-list.vercel.app/&quot;&gt;https://linux-command-list.vercel.app&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;配置 openclash&lt;/h2&gt;
&lt;p&gt;这里记录一下一些 openclash 配置项。&lt;/p&gt;
&lt;h3&gt;插件配置&lt;/h3&gt;
&lt;p&gt;带星号标红的是必须要确认的项，其他基本保持默认即可，也可根据自己的需求更改。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;模式设置&lt;/code&gt;：运行模式建议&lt;code&gt;使用Fake-IP增强模式&lt;/code&gt;，性能更好。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;流量控制&lt;/code&gt;：可以勾选&lt;code&gt;实验性：绕过中国大陆 IP&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DNS 设置&lt;/code&gt;：本地 dns 劫持选择&lt;code&gt;使用dnsmasq转发&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;流媒体增强&lt;/code&gt;：根据个人需求配置，我没需求所以没改。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;黑白名单&lt;/code&gt;：根据个人需求配置，我没需求所以没改。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;外部控制&lt;/code&gt;：clash 的 UI 面板，设置一下登录密码就行。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;IPv6 设置&lt;/code&gt;：根据个人需求配置，我没需求所以没改。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;第三方规则订阅&lt;/code&gt;：使用了内置的第三方规则集的，可以配置一下自动更新。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;GEO 数据库订阅&lt;/code&gt;：GEO 数据库的订阅及自动更新&lt;/li&gt;
&lt;li&gt;&lt;code&gt;大陆白名单订阅&lt;/code&gt;：配置白名单列表订阅及自动更新&lt;/li&gt;
&lt;li&gt;&lt;code&gt;定时重启&lt;/code&gt;：设置定时重启&lt;/li&gt;
&lt;li&gt;&lt;code&gt;版本更新&lt;/code&gt;：更新内核的界面，使用 meta 内核首次设置需要下载安装&lt;/li&gt;
&lt;li&gt;&lt;code&gt;开发者选项&lt;/code&gt;：大佬专属界面，不知道做什么的，之后有机会研究一下&lt;/li&gt;
&lt;li&gt;&lt;code&gt;调试日志&lt;/code&gt;：debug 时候用&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;顺便分享一下我的配置，也防止我自己时间久了就忘记了：&lt;/p&gt;
&lt;p&gt;&amp;lt;details&amp;gt;
&amp;lt;summary&amp;gt;🔔多图预警&amp;lt;/summary&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;details&amp;gt;
&amp;lt;summary&amp;gt;插件设置&amp;lt;/summary&amp;gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pichost.netlify.app/blog/656039ce51f42.webp&quot; alt=&quot;模式设置&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pichost.netlify.app/blog/656039fa93b44.webp&quot; alt=&quot;流量控制&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pichost.netlify.app/blog/656039c587845.webp&quot; alt=&quot;DNS设置&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pichost.netlify.app/blog/656039ffc6482.webp&quot; alt=&quot;版本更新&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;/details&amp;gt;
&amp;lt;br/&amp;gt;
&amp;lt;details&amp;gt;
&amp;lt;summary&amp;gt;覆写设置&amp;lt;/summary&amp;gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pichost.netlify.app/blog/656039e48abca.webp&quot; alt=&quot;DNS设置&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pichost.netlify.app/blog/656039e98ab50.webp&quot; alt=&quot;meta设置&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pichost.netlify.app/blog/656039ef1e14a.webp&quot; alt=&quot;规则设置&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pichost.netlify.app/blog/656039f500dc2.webp&quot; alt=&quot;第三方规则集&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;/details&amp;gt;
&amp;lt;br/&amp;gt;
&amp;lt;details&amp;gt;
&amp;lt;summary&amp;gt;规则附加&amp;lt;/summary&amp;gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pichost.netlify.app/blog/656039aab527b.webp&quot; alt=&quot;规则附加&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;/details&amp;gt;
&amp;lt;/details&amp;gt;&lt;/p&gt;
</content:encoded></item><item><title>Cloudflare Tunnel 不完全上手指南</title><link>https://smj.im/blag/posts/cloudflare-tunnel-guide/</link><guid isPermaLink="true">https://smj.im/blag/posts/cloudflare-tunnel-guide/</guid><description>如何使用免费的Cloudflare Tunnel进行内网穿透，把树莓派整成家用服务器，实现数据私有化。</description><pubDate>Sat, 01 Apr 2023 13:04:52 GMT</pubDate><content:encoded>&lt;p&gt;最近在树莓派上整了几个 web 服务，不过只能在本地使用，无法通过外网访问，所以试着使用 Cloudflare Tunnel 来进行内网穿透，这里记录下我的操作过程。&lt;/p&gt;
&lt;p&gt;我的硬件配置&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;树莓派 4B+Ubuntu 系统&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;安装 cloudflared&lt;/h2&gt;
&lt;p&gt;要在 Raspberry Pi 上设置 Cloudflare 隧道，我们将依赖一个名为“ &lt;code&gt;Cloudflared&lt;/code&gt; ”的软件，Cloudflared 是在 本地网络 和 Cloudflare 网络之间创建和维护安全隧道的软件。有两种安装方法。&lt;/p&gt;
&lt;h3&gt;方法 1：使用 Cloudflare 存储库&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;获取 Cloudflared 存储库的 GPG 密钥&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;curl -L https://pkg.cloudflare.com/cloudflare-main.gpg | sudo tee /usr/share/keyrings/cloudflare-archive-keyring.gpg &amp;gt;/dev/null
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;将 Cloudflared 存储库添加到软件源&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;echo &quot;deb [signed-by=/usr/share/keyrings/cloudflare-archive-keyring.gpg] https://pkg.cloudflare.com/cloudflared $(lsb_release -cs) main&quot; | sudo tee  /etc/apt/sources.list.d/cloudflared.list
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;更新软件包缓存并安装&lt;code&gt;cloudflared&lt;/code&gt;：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;sudo apt update
sudo apt install cloudflared
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;方法 2：直接使用官方 deb 包&lt;/h3&gt;
&lt;p&gt;使用以下在 Github 的&lt;a href=&quot;https://github.com/cloudflare/cloudflared/releases&quot;&gt;Release&lt;/a&gt;界面下载最新版 deb 包，并使用&lt;code&gt;dpkg&lt;/code&gt;进行安装：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;wget -q https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-linux-arm64.deb &amp;amp;&amp;amp; sudo dpkg -i cloudflared-linux-arm64.deb
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;注意树莓派 4B 安装&lt;/em&gt;&lt;code&gt;_arm64_&lt;/code&gt;&lt;em&gt;版本。&lt;/em&gt;&lt;/p&gt;
&lt;h2&gt;配置账号&lt;/h2&gt;
&lt;p&gt;命令行执行以下命令，按照引导进行账号验证：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cloudflared tunnel login
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;创建隧道&lt;/h2&gt;
&lt;p&gt;执行以下命令，创建一个 tunnel：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cloudflared tunnel create &amp;lt;tunnel-name&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行上面的命令后，您将看到类似于下面的消息&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Tunnel credentials written to /home/pi/.cloudflared/XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX.json. cloudflared chose this file based on where your origin certificate was found. Keep this file secret. To revoke these credentials, delete the tunnel.

Created tunnel pimytunnel with id XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这一步在创建 tunnel 的同时，还生成一个 tunnel 的 UUID，一个凭证文件以及一个&lt;code&gt;.cfargotunnel.com&lt;/code&gt; 的子域名，UUID 以及凭证文件将在之后配置文件时使用，务必记住 UUID 以及凭证文件的路径（在默认路径中，后面会提到）。&lt;/p&gt;
&lt;p&gt;也使用以下命令验证是否创建成功：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cloudflared tunnel list
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;详细配置隧道&lt;/h3&gt;
&lt;p&gt;配置文件的默认路径有 3 个，分别是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;~/.cloudflared&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/etc/cloudflared&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/usr/local/etc/cloudflared&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这里我们使用当前用户目录，即&lt;code&gt;~/.cloudflared&lt;/code&gt;，我们在该目录下面创建一个配置文件，命名为&lt;code&gt;config.yml&lt;/code&gt;，并填入之前创建的 tunnel 时的生成的配置信息：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;tunnel: &amp;lt;Tunnel-UUID&amp;gt;
credentials-file: /home/pi/.cloudflared/&amp;lt;Tunnel-UUID&amp;gt;.json

ingress:
        - hostname: test.example.com
          service: http://localhost:80
        - hostname: example.com
          service: https://localhost:8000
        - service: http_status:404
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后按照配置文件的格式配置自己的 web 服务的主机名和端口，每个规则一般包含&lt;code&gt;hostname&lt;/code&gt;和&lt;code&gt;service&lt;/code&gt;两部分，注意最后一行的&lt;code&gt;- service: http_status:404&lt;/code&gt;，我们可以发现没有 hostname 部分，这并不是错误，而是&lt;code&gt;cloudflared&lt;/code&gt;的特殊规则，主要是用来匹配所有流量，是必须要有的。&lt;/p&gt;
&lt;p&gt;这和&lt;code&gt;cloudflared&lt;/code&gt;匹配规则有关，当 &lt;code&gt;cloudflared&lt;/code&gt; 收到传入请求时，它会从上到下评估每个入口规则，以找到与请求匹配的规则。规则可以匹配传入请求的主机名或路径，或两者。如果所有规则都不匹配，就会匹配最后一条规则。&lt;/p&gt;
&lt;h2&gt;路由内网服务流量&lt;/h2&gt;
&lt;p&gt;使用以下命令分配一个 CNAME 记录，将流量指向您的隧道子域。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cloudflared tunnel route dns &amp;lt;UUID or NAME&amp;gt; &amp;lt;hostname&amp;gt;

# example
cloudflared tunnel route dns pi test.example.com
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;运行隧道&lt;/h2&gt;
&lt;p&gt;执行以下命令，将 cloudflared 连接到 Cloudflare 的网络，Cloudflared 会从默认位置检索配置文件，即 &lt;code&gt;~/.cloudflared/config.yml&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cloudflared tunnel run &amp;lt;UUID or NAME&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果你的配置文件不在默认路径，可以使用&lt;code&gt;--config&lt;/code&gt;选项来运行隧道：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cloudflared tunnel --config /path/your-config-file.yaml run &amp;lt;UUID or NAME&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;检查隧道参数&lt;/h2&gt;
&lt;p&gt;至此，隧道配置完成，可以执行下面的命令来获得刚刚创建的隧道的信息：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cloudflared tunnel info
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其他一些常用的命令：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Functions&lt;/th&gt;
&lt;th&gt;Commands&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;创建隧道&lt;/td&gt;
&lt;td&gt;cloudflared tunnel run &amp;lt;&lt;em&gt;NAME&lt;/em&gt;&amp;gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;隧道列表&lt;/td&gt;
&lt;td&gt;cloudflared tunnel list&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;停止隧道&lt;/td&gt;
&lt;td&gt;cloudflared tunnel stop &amp;lt;&lt;em&gt;NAME&lt;/em&gt;&amp;gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;重新启动隧道&lt;/td&gt;
&lt;td&gt;cloudflared tunnel restart &amp;lt;&lt;em&gt;NAME&lt;/em&gt;&amp;gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;删除隧道&lt;/td&gt;
&lt;td&gt;cloudflared tunnel delete &amp;lt;&lt;em&gt;NAME&lt;/em&gt;&amp;gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;强制删除隧道&lt;/td&gt;
&lt;td&gt;cloudflared tunnel delete -f &amp;lt;&lt;em&gt;NAME&lt;/em&gt;&amp;gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;显示隧道信息&lt;/td&gt;
&lt;td&gt;cloudflared tunnel info &amp;lt;&lt;em&gt;NAME&lt;/em&gt;&amp;gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;将隧道作为服务运行&lt;/h2&gt;
&lt;p&gt;将 Tunnel 安装为系统服务，允许 Tunnel 在启动时作为启动守护进程自动运行。默认情况下，Tunnel 希望在默认目录 &lt;code&gt;~/.cloudflared/config.yml&lt;/code&gt; 中找到配置文件，但要将 Tunnel 作为服务运行，我们需要将 config.yml 文件移动到 &lt;code&gt;~/etc/cloudflared/&lt;/code&gt; 中。&lt;/p&gt;
&lt;p&gt;使用 &lt;code&gt;mv&lt;/code&gt; 命令来移动配置文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo mv /home/pi/.cloudflared/config.yml /etc/cloudflared/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后执行以下命令安装服务：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo cloudflared service install
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;启动服务：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;systemctl start cloudflared
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;检查服务运行状态：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;systemctl status cloudflared
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;踩坑&lt;/h2&gt;
&lt;p&gt;启动隧道服务时遇到的一个问题：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;failed to sufficiently increase receive buffer size (was: 208 kiB, wanted: 2048 kiB, got: 416 kiB).&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;解决方法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo sysctl -w net.core.rmem_max=2500000
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;参考&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://developers.cloudflare.com/cloudflare-one/connections/connect-apps/install-and-setup/&quot;&gt;https://developers.cloudflare.com/cloudflare-one/connections/connect-apps/install-and-setup/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/quic-go/quic-go/wiki/UDP-Receive-Buffer-Size&quot;&gt;https://github.com/quic-go/quic-go/wiki/UDP-Receive-Buffer-Size&lt;/a&gt;&lt;/p&gt;
</content:encoded></item><item><title>解除New Bing地区和浏览器限制的方法</title><link>https://smj.im/blag/posts/unlock-new-bing-ai/</link><guid isPermaLink="true">https://smj.im/blag/posts/unlock-new-bing-ai/</guid><description>本文介绍两种方法。可以解除微软实行的New Bing地区限制以及用户只能通过自家Edge浏览器使用New Bing的限制。</description><pubDate>Wed, 29 Mar 2023 11:00:28 GMT</pubDate><content:encoded>&lt;h2&gt;Part I：解除地区限制&lt;/h2&gt;
&lt;p&gt;最近，由于不可描述的原因，在大陆地区使用 New Bing 时会出现：&quot;Sorry,looks like your network settings are preventing access to this feature.&quot;的问题。
&lt;img src=&quot;https://pichost.netlify.app/blog/65603a1730042.webp&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;p&gt;一个比较简单的解决方案：修改请求 &lt;code&gt;header&lt;/code&gt; 中&lt;code&gt;X-Forwarder-For&lt;/code&gt;字段的 ip 地址。&lt;/p&gt;
&lt;p&gt;具体操作步骤如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;设置 bing 账户的地区为大陆以外的地区，例如美国。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;安装浏览器插件
Firefox: &lt;a href=&quot;https://microsoftedge.microsoft.com/addons/detail/modheader-modify-http-h/opgbiafapkbbnbnjcdomjaghbckfkglc&quot;&gt;ModHeader&lt;/a&gt; or &lt;a href=&quot;https://microsoftedge.microsoft.com/addons/detail/header-editor/afopnekiinpekooejpchnkgfffaeceko&quot;&gt;Header Editor&lt;/a&gt;
Chromium Based(Edge/Chrome): &lt;a href=&quot;https://microsoftedge.microsoft.com/addons/detail/modheader-modify-http-h/opgbiafapkbbnbnjcdomjaghbckfkglc&quot;&gt;ModHeader&lt;/a&gt; or &lt;a href=&quot;https://microsoftedge.microsoft.com/addons/detail/header-editor/afopnekiinpekooejpchnkgfffaeceko&quot;&gt;Header Editor&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;查找美国 ip 段或者 ip 地址，记录一个位于的美国 ip 地址，例如：&lt;code&gt;1.32.232.xxx&lt;/code&gt;是一个美国 ip 段，其中的&lt;code&gt;xxx&lt;/code&gt;可以是 255 以内的任何值。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;配置插件
修改请求 header 中的&lt;code&gt;X-Forwarder-For&lt;/code&gt;字段，设置值为刚刚找到的 ip 地址&lt;code&gt;1.32.232.123&lt;/code&gt;
设置匹配的 url 为所有&lt;code&gt;bing.com&lt;/code&gt;的请求：&lt;code&gt;.*://www.bing.com/.*&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;Header Editor&lt;/strong&gt;配置示例&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pichost.netlify.app/blog/65603a0be5f37.webp&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ModHeader&lt;/strong&gt;配置示例&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pichost.netlify.app/blog/65603a11ba27e.webp&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;p&gt;按照上面的步骤设置之后，应该就可以使用 New Bing 了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pichost.netlify.app/blog/656037ffaf765.webp&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;Part II：解除浏览器限制&lt;/h2&gt;
&lt;p&gt;又因为各种原因，如果想要使用 New Bing，必须使用微软自家的 Edge 浏览器，虽然很强大，但是我用习惯了 Firefox，所以不想切换。但是也不想为了使用这个功能而来回切换浏览器，太麻烦了。&lt;/p&gt;
&lt;p&gt;所以这里给出一个解决方案：更改浏览器的 UA(UserAgent)。&lt;/p&gt;
&lt;p&gt;具体操作：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;下载&lt;a href=&quot;https://addons.mozilla.org/en-US/firefox/addon/user-agent-string-switcher/?utm_content=addons-manager-reviews-link&amp;amp;utm_medium=firefox-browser&amp;amp;utm_source=firefox-browser&quot;&gt;User-Agent Switcher and Manager&lt;/a&gt;插件&lt;/li&gt;
&lt;li&gt;按照下图切换为 Edge 浏览器 UA，点击 Apply
&lt;img src=&quot;https://pichost.netlify.app/blog/6560383ff1bc1.webp&quot; alt=&quot;image&quot; /&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;现在应该可以在 Firefox 使用 New Bing 了。
&lt;img src=&quot;https://pichost.netlify.app/blog/6560371beb3cf.webp&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
</content:encoded></item><item><title>FRP上手教程</title><link>https://smj.im/blag/posts/frp-tutorial/</link><guid isPermaLink="true">https://smj.im/blag/posts/frp-tutorial/</guid><pubDate>Sat, 25 Mar 2023 10:47:15 GMT</pubDate><content:encoded>&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;最近把在角落里吃灰的树莓派拿了出来，搭建了一个 wordpress 网站，感觉还不错，不过因为连的是家里的 WiFi，所以只能内网访问，所以就准备用内网穿透工具配置一下外网访问。之前内网穿透都是用的 Cloudflare 的 tunnel，免费，配置很简单，而且直接上自家的 CDN 网络，但是由于众所周知的原因，Cloudflare 的服务在国内访问速度感人，但是勉强还能用。不过最近在 Github 上的 Trending 里看到了这个&lt;a href=&quot;https://github.com/fatedier/frp&quot;&gt;frp&lt;/a&gt;，看了一下文档，发现这个工具配置起来超简单，刚好有台服务器，所以就直接上手了。&lt;/p&gt;
&lt;p&gt;个人配置&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Client: Raspberrypi 4B + Ubuntu 20.04&lt;/p&gt;
&lt;p&gt;Server: Ubuntu 20.04&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;安装配置 frp&lt;/h2&gt;
&lt;h3&gt;服务器端配置&lt;/h3&gt;
&lt;p&gt;下载解压 frp 文件，注意安装包的架构：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;wget https://github.com/fatedier/frp/releases/download/v0.46.1/frp_0.46.1_linux_amd64.tar.gz

tar zxvf frp_0.46.1_linux_amd64.tar.gz

cd frp_0.46.1_linux_arm64/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;配置流程稍稍与客户端配置不同，但是更简单，只需要编辑&lt;code&gt;frps.ini&lt;/code&gt;配置文件，设置监听 HTTP 请求端口，这里我使用的 8080 端口：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[common]
bind_port = 7000 # frp服务的监听端口
vhost_http_port = 8080
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;p.s. 不要忘记开放服务器的防火墙端口。&lt;/p&gt;
&lt;h3&gt;客户端配置&lt;/h3&gt;
&lt;p&gt;下载解压 frp 文件，因为我用的是树莓派，所以下载 arm64 的包：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;wget https://github.com/fatedier/frp/releases/download/v0.46.1/frp_0.46.1_linux_arm64.tar.gz

tar zxvf frp_0.46.1_linux_arm64.tar.gz
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;编辑&lt;code&gt;frpc.ini&lt;/code&gt;配置文件，设置服务器的 IP 地址&lt;code&gt;a.b.c.d&lt;/code&gt;及本地机器上 Web 服务监听的端口，并绑定自定义域名：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[common]
server_addr = a.b.c.d
server_port = 7000

[web]
type = http
local_port = 3000
custom_domains = www.yourdomain.com #这里设置域名
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;到这里就可以使用了，分别启动服务端和客户端即可。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 服务端
./frps -c ./frps.ini

# 客户端
./frpc -c ./frpc.ini
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过&lt;code&gt;http://www.yourdomain.com&lt;/code&gt;即可访问 web 服务。p.s. 不要忘记将&lt;code&gt;www.yourdomain.com&lt;/code&gt;的域名 A 记录映射到服务器的 IP。&lt;/p&gt;
&lt;h2&gt;Caddy 配置&lt;/h2&gt;
&lt;p&gt;不过因为我的服务器上还部署了其他的 web 服务，使用了 caddy 进行反向代理，所以还需要一点额外的配置。编辑 caddy 的配置文件&lt;code&gt;/etc/caddy/Caddyfile&lt;/code&gt;，添加新域名的反向代理：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;www.yourdomain.com {
    reverse_proxy localhost:8080
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;重新启动 caddy 服务：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo systemctl restart caddy
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;现在就可以通过&lt;code&gt;https://www.yourdomain.com&lt;/code&gt;访问内网的 web 服务了，而且 Auto HTTPS！！&lt;/p&gt;
&lt;h2&gt;参考&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/fatedier/frp/&quot;&gt;https://github.com/fatedier/frp/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://gofrp.org/docs/&quot;&gt;https://gofrp.org/docs/&lt;/a&gt;&lt;/p&gt;
</content:encoded></item><item><title>深入理解Linux nohup命令</title><link>https://smj.im/blag/posts/linux-nohup-and-uses/</link><guid isPermaLink="true">https://smj.im/blag/posts/linux-nohup-and-uses/</guid><pubDate>Thu, 23 Feb 2023 18:13:56 GMT</pubDate><content:encoded>&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;当我们在 Linux 或 Unix 系统上执行一个长时间运行的命令或脚本时，我们通常会遇到一个问题，那就是在终端关闭或者退出后，该进程也会随之停止运行。在这种情况下，我们需要一种方式来让进程在后台运行，而不受终端关闭的影响。这时，nohup 命令就派上用场了。&lt;/p&gt;
&lt;h2&gt;nohup 是什么？&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;nohup&lt;/code&gt;是 Linux 和 Unix 系统中的一个命令，其作用是在终端退出时，让进程在后台继续运行。它的全称为“no hang up”，意为“不挂起”。&lt;code&gt;nohup&lt;/code&gt;命令可以让你在退出终端或关闭 SSH 连接后继续运行命令。&lt;/p&gt;
&lt;h2&gt;nohup 语法规则&lt;/h2&gt;
&lt;p&gt;nohup 命令的基本语法如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;nohup COMMAND [ARGS ...] [&amp;gt; output-file 2&amp;gt; error-file] &amp;amp;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中的参数含义如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;COMMAND&lt;/code&gt;：需要在后台运行的命令或脚本。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ARGS&lt;/code&gt;：命令或脚本的参数。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;gt; output-file&lt;/code&gt;：输出重定向到指定的文件中。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;2&amp;gt; error-file&lt;/code&gt;：错误信息重定向到指定的文件中。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;amp;&lt;/code&gt;：将命令放在后台运行。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;nohup 命令的执行过程分为以下几个步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;nohup 命令将当前 shell 的标准输入、标准输出和标准错误输出全部重定向到&lt;code&gt;/dev/null&lt;/code&gt;设备中，避免被关闭终端的信号所中断。&lt;/li&gt;
&lt;li&gt;nohup 命令将进程放到后台执行，并将进程的 PID 输出到终端。&lt;/li&gt;
&lt;li&gt;进程开始执行，并将标准输出和标准错误输出重定向到指定的文件中。&lt;/li&gt;
&lt;li&gt;用户可以退出终端或关闭终端窗口，进程仍然在后台运行。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;nohup 使用方法&lt;/h2&gt;
&lt;p&gt;使用 nohup 命令非常简单，按照上面的基本语法即可。以下是一些 nohup 命令的用法示例：&lt;/p&gt;
&lt;h3&gt;后台运行命令&lt;/h3&gt;
&lt;p&gt;要在后台运行命令，只需要在命令行中输入以下命令即可：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;nohup COMMAND &amp;amp;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;例如，在后台运行一个 Bash 脚本：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;nohup bash test.sh &amp;amp;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;标准输出重定向到文件&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;nohup bash test.sh &amp;gt; stdout.txt &amp;amp;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;标准错误输出重定向到文件&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;nohup bash test.sh 2&amp;gt; stderr.txt &amp;amp;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;将标准输出和标准错误输出都重定向到文件&lt;/h3&gt;
&lt;p&gt;1. 重定向到同一文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;nohup bash test.sh &amp;gt; output.txt 2&amp;gt;&amp;amp;1 &amp;amp;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2. 重定向到不同文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;nohup bash test.sh &amp;gt; stdout.txt 2&amp;gt; stderr.txt &amp;amp;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3. 一个&lt;a href=&quot;https://en.wikipedia.org/wiki/Nohup#Overcoming_hanging&quot;&gt;更为复杂的例子&lt;/a&gt;，重定向标准输入（stdin）：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;nohup ./myprogram &amp;gt; foo.out 2&amp;gt; foo.err &amp;lt; /dev/null &amp;amp;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里多出来一个&lt;code&gt;&amp;lt; /dev/null&lt;/code&gt;，意思是将标准输入重定向到&lt;code&gt;/dev/null&lt;/code&gt;，以确保程序不会从标准输入中读取任何数据。&lt;/p&gt;
&lt;p&gt;这个是为了解决一个实际问题：SSH 会话常常拒绝注销（或者挂起），因为它不愿意去丢失与后台 job(s)进行交互的数据。当遇到这个问题的时候，可以使用上面的命令，通过三次重定向来解决。&lt;/p&gt;
&lt;h3&gt;nohup 后台进程管理&lt;/h3&gt;
&lt;p&gt;使用 &lt;code&gt;jobs&lt;/code&gt; 命令可以查看当前 shell 中后台运行的任务列表，包括任务编号、状态和命令。&lt;/p&gt;
&lt;p&gt;例如，我们在后台执行一个&lt;code&gt;sleep 1000&lt;/code&gt;命令，使用&lt;code&gt;jobs&lt;/code&gt;命令查看：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ jobs
[1]+  Running                 nohup sleep 1000 &amp;amp;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中，方括号中的数字表示任务编号，加号或减号表示任务的优先级，&lt;code&gt;Running&lt;/code&gt; 表示任务正在后台运行。除此之外，还有其他可能的状态，包括 &lt;code&gt;Stopped&lt;/code&gt;（已停止）、&lt;code&gt;Done&lt;/code&gt;（已完成）等。&lt;/p&gt;
&lt;p&gt;我们还可以使用 &lt;code&gt;fg&lt;/code&gt; 命令将一个后台任务移动到前台继续运行，例如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ fg %1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个命令会将任务编号为 1 的任务移动到前台，继续执行。如果希望将任务暂停或恢复，可以使用 &lt;code&gt;Ctrl-Z&lt;/code&gt; 键，在当前 shell 中发送 &lt;code&gt;SIGTSTP&lt;/code&gt; 信号。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ fg %1
nohup sleep 1000

^Z
[1]+  Stopped                 nohup sleep 1000
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;此时如果想要恢复运行，可以使用&lt;code&gt;bg&lt;/code&gt;命令：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ bg %1
[1]+ nohup sleep 1000 &amp;amp;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果想要杀死该任务，可以使用&lt;code&gt;kill&lt;/code&gt;命令：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ kill %1
[1]+  Terminated              nohup sleep 1000
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果你想杀死所有后台任务，但是又觉得一个个地比较麻烦，可以使用&lt;code&gt;disown&lt;/code&gt;命令来解决：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ disown -a
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个命令可以杀死所有后台任务，但不会有任何提示，你可以通过&lt;code&gt;jobs&lt;/code&gt;命令来确认。&lt;/p&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;nohup&lt;/code&gt;命令可以在后台运行程序，即使终端关闭或断开与远程服务器的连接也不会影响程序的运行。通过&lt;code&gt;nohup&lt;/code&gt;命令启动的进程会忽略所有终端信号，因此即使使用&lt;code&gt;Ctrl+C&lt;/code&gt;关闭终端，进程也不会停止。可以使用&lt;code&gt;jobs&lt;/code&gt;命令查看后台运行的进程，并使用&lt;code&gt;fg&lt;/code&gt;命令将进程切换到前台运行。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;nohup&lt;/code&gt;非常适合用来执行一些需要长时间运行的脚本或程序，比如 Web 服务器，数据库等。但需要注意的是，&lt;code&gt;nohup&lt;/code&gt;命令并不是完全避免了进程被中断的可能，例如系统崩溃、进程错误等情况仍可能导致进程的中断。&lt;/p&gt;
&lt;h2&gt;参考&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Nohup&quot;&gt;https://en.wikipedia.org/wiki/Nohup&lt;/a&gt;&lt;/p&gt;
</content:encoded></item><item><title>C++智能指针是什么</title><link>https://smj.im/blag/posts/what-is-cpp-smart-pointer/</link><guid isPermaLink="true">https://smj.im/blag/posts/what-is-cpp-smart-pointer/</guid><description>详细介绍了C++智能指针的基本概念并通过几个简单的例子讲解C++的使用技巧及注意事项。</description><pubDate>Thu, 23 Feb 2023 18:13:31 GMT</pubDate><content:encoded>&lt;h2&gt;引言&lt;/h2&gt;
&lt;p&gt;C++是一种广泛使用的编程语言，它允许程序员使用动态分配的内存。然而，手动管理内存可能会导致一些严重的问题，如内存泄漏和悬空指针。为了解决这些问题，C++引入了智能指针的概念。智能指针是一种特殊的指针类型，它可以自动管理内存并确保在不需要时释放内存。智能指针在 C++程序中的使用已经变得越来越普遍，例如在 STL 容器中使用的智能指针、COM 接口编程等。&lt;/p&gt;
&lt;p&gt;本文将介绍智能指针的概念、类型以及实现原理，帮助大家更好地理解和应用智能指针。&lt;/p&gt;
&lt;h2&gt;基本概念&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;智能指针&lt;/strong&gt;是一种 C++语言特有的指针，它是对常规指针的封装，提供了自动内存管理的功能，能够在对象不再被使用时自动释放其所占用的内存，避免了手动管理内存所带来的错误和麻烦。智能指针的设计思想是资源管理类（&lt;strong&gt;RAII&lt;/strong&gt;）的一种应用，通过将对象的生命周期与智能指针的生命周期绑定，实现对对象的自动管理。&lt;/p&gt;
&lt;p&gt;与常规指针相比，智能指针具有以下特点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;自动管理内存，不需要手动释放内存；&lt;/li&gt;
&lt;li&gt;可以记录指针的引用计数，并自动管理对象的生命周期；&lt;/li&gt;
&lt;li&gt;可以模拟对象拷贝的效果，并保证在析构时不会释放同一块内存两次；&lt;/li&gt;
&lt;li&gt;可以通过指定删除器（deleter）来实现自定义资源的管理。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;然而，智能指针也有一些缺点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;额外的开销：智能指针在实现上需要额外的开销来管理指针的生命周期，这可能会导致一些性能问题。&lt;/li&gt;
&lt;li&gt;循环引用问题：在使用 shared_ptr 时，如果存在循环引用的情况，即两个或多个对象互相持有 shared_ptr 指针，可能会导致内存泄漏。&lt;/li&gt;
&lt;li&gt;无法处理非堆内存对象：智能指针只适用于堆内存对象，无法管理栈内存或全局变量等非堆内存对象。&lt;/li&gt;
&lt;li&gt;不支持数组：智能指针只能管理单个对象，无法管理数组。如果需要管理数组，需要使用专门的数组智能指针。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;智能指针的生命周期&lt;/strong&gt;由其作用域和引用计数共同决定。当智能指针对象超出作用域时，会自动释放其所指向的内存，从而避免了内存泄漏的问题。而当多个智能指针指向同一个对象时，其引用计数会增加，当引用计数为 0 时，对象才会被释放。也就是说，智能指针的作用域和生命周期是自动管理的，能够有效避免内存泄漏和其他内存管理问题的出现。&lt;/p&gt;
&lt;h2&gt;智能指针类型&lt;/h2&gt;
&lt;p&gt;C++中常见的智能指针类型有 unique_ptr、shared_ptr 和 weak_ptr。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;unique_ptr
unique_ptr 是一种独占智能指针，它以独占所有权的方式管理资源。这意味着，每个资源只能由一个 unique_ptr 所拥有，一旦 unique_ptr 被销毁，它所拥有的资源也会被释放。unique_ptr 是 C++11 标准中新增的特性，它提供了更高效和更安全的资源管理方式。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;shared_ptr
shared_ptr 是一种共享智能指针，它允许多个 shared_ptr 共享同一个资源，这个资源会在所有引用它的 shared_ptr 对象被销毁后才被释放。shared_ptr 通过使用引用计数的方式来追踪资源的使用情况，一旦引用计数为 0，资源会被释放。与 unique_ptr 不同，shared_ptr 可以传递拥有权，并且可以从裸指针或者其他 shared_ptr 对象构造出来。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;weak_ptr
weak_ptr 是一种弱引用智能指针，它是 shared_ptr 的一种扩展，但它并不对资源进行引用计数。它只能从一个 shared_ptr 对象中构造而来，并且不能直接操作被管理的资源。一般情况下，我们&lt;strong&gt;使用 weak_ptr 来解决 shared_ptr 的循环引用问题&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;使用技巧&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;尽量使用&lt;code&gt;unique_ptr&lt;/code&gt;：在不需要共享所有权的情况下，尽量使用 unique_ptr。它可以确保指针所有权唯一，避免内存泄漏的发生，并且具有良好的性能。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用&lt;code&gt;shared_ptr&lt;/code&gt;管理共享资源：在需要多个对象共享同一个资源时，应该使用&lt;code&gt;shared_ptr&lt;/code&gt;。&lt;code&gt;shared_ptr&lt;/code&gt;使用引用计数技术，可以确保资源只有在最后一个拥有者被销毁时才会被释放。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用&lt;code&gt;make_shared&lt;/code&gt;或&lt;code&gt;make_unique&lt;/code&gt;创建智能指针：在创建智能指针时，应该尽可能地使用 &lt;code&gt;make_shared&lt;/code&gt; 或 &lt;code&gt;make_unique&lt;/code&gt; 函数，而不是直接使用 new 操作符。这样可以减少内存分配的开销，并且可以避免内存泄漏的发生。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不要使用智能指针数组：智能指针不支持管理动态数组，因此在需要管理数组的情况下，应该使用标准库中的容器类，如&lt;code&gt;vector&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;避免使用裸指针：尽可能地避免使用裸指针，因为它们很容易被误用。尤其是在使用智能指针时，应该尽量避免将裸指针和智能指针混合使用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不要将智能指针转换为裸指针：在使用智能指针时，应该尽可能地避免将智能指针转换为裸指针。如果必须要进行转换，应该使用 get 函数来获取裸指针，而不是直接使用智能指针的地址。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将智能指针传递给函数时应该使用&lt;code&gt;const&lt;/code&gt;引用：当需要将智能指针作为参数传递给函数时，应该尽量使用&lt;code&gt;const&lt;/code&gt;引用，以避免不必要的拷贝和内存分配。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;注意事项&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;注意循环引用问题
shared_ptr 是一种智能指针类型，它可以在多个指针之间共享所指向的对象。但是，如果存在循环引用，就可能导致内存泄漏的问题。
循环引用指的是两个或多个对象之间相互引用，导致它们之间的引用计数无法达到零，从而导致内存泄漏。为了避免循环引用，可以采用如下几种方法：&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;使用 weak_ptr 来打破循环引用&lt;/li&gt;
&lt;li&gt;尽量避免循环引用的发生&lt;/li&gt;
&lt;li&gt;使用标准库提供的容器，如 std::list 或 std::vector，而不是手动管理内存&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;注意线程安全问题
多线程环境下，使用智能指针需要注意线程安全问题。如果多个线程同时访问同一个智能指针，可能会导致竞争条件的问题。为了避免这种问题，可以采用如下几种方法：&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;使用原子操作来保证线程安全&lt;/li&gt;
&lt;li&gt;使用互斥锁来保证线程安全&lt;/li&gt;
&lt;li&gt;避免多线程同时访问同一个智能指针&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;避免内存泄漏和悬空指针
智能指针的主要作用是管理动态分配的内存，避免内存泄漏和悬垂指针。但是，如果使用不当，仍然可能发生这些问题。为了避免内存泄漏和悬垂指针，应该遵循以下几点：&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;使用智能指针来管理动态分配的内存&lt;/li&gt;
&lt;li&gt;不要使用裸指针和 delete 来管理内存&lt;/li&gt;
&lt;li&gt;不要手动释放智能指针管理的内存&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;示例&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;memory&amp;gt;

using namespace std;

class MyClass {
public:
    void print() {
        cout &amp;lt;&amp;lt; &quot;Hello from MyClass!&quot; &amp;lt;&amp;lt; endl;
    }
};

void test_unique_ptr() {
    unique_ptr&amp;lt;MyClass&amp;gt; p(new MyClass());
    p-&amp;gt;print();
}

void test_shared_ptr() {
    shared_ptr&amp;lt;MyClass&amp;gt; p(new MyClass());
    p-&amp;gt;print();
}

void test_weak_ptr() {
    shared_ptr&amp;lt;MyClass&amp;gt; p1(new MyClass());
    weak_ptr&amp;lt;MyClass&amp;gt; p2(p1);
    if (!p2.expired()) {
        shared_ptr&amp;lt;MyClass&amp;gt; p3 = p2.lock();
        p3-&amp;gt;print();
    }
}

int main() {
    test_unique_ptr();
    test_shared_ptr();
    test_weak_ptr();
    return 0;
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述代码中，我们定义了一个名为 MyClass 的类，其实例拥有一个 print() 方法，用于打印一条消息。&lt;/p&gt;
&lt;p&gt;接着，我们定义了三个测试函数：test_unique_ptr()、test_shared_ptr() 和 test_weak_ptr()，分别使用了 unique_ptr、shared_ptr 和 weak_ptr 智能指针类型。&lt;/p&gt;
&lt;p&gt;在 test_unique_ptr() 中，我们使用了 unique_ptr，它拥有独占的所有权，用于管理 MyClass 类型的实例。我们使用 new 运算符来创建这个实例，然后使用箭头操作符访问它的 print() 方法。&lt;/p&gt;
&lt;p&gt;在 test_shared_ptr() 中，我们使用了 shared_ptr，它可以与其他 shared_ptr 共享同一个实例。我们同样使用 new 运算符创建 MyClass 类型的实例，并传递给 shared_ptr，它会自动跟踪实例的引用计数。同样，我们使用箭头操作符访问实例的 print() 方法。&lt;/p&gt;
&lt;p&gt;在 test_weak_ptr() 中，我们定义了一个 shared_ptr 类型的实例 p1，然后创建了一个指向它的 weak_ptr 类型的实例 p2。由于 weak_ptr 并不会增加引用计数，因此它不能直接访问 MyClass 实例，需要先通过 lock() 方法获取一个 shared_ptr 类型的实例 p3，然后才能使用箭头操作符访问实例的 print() 方法。&lt;/p&gt;
&lt;p&gt;通过上述示例，我们可以看到不同类型的智能指针的使用方法和特点。需要注意的是，在实际开发中，我们需要根据具体的场景和需求，选择最合适的智能指针类型，以达到最佳的效果。&lt;/p&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;智能指针是一种 C++中常用的内存管理工具，能够自动管理对象的生命周期，有效避免内存泄漏和资源占用等问题。本文主要介绍了普通指针和智能指针的区别，以及智能指针的分类和特点。我们对每种类型进行了介绍和比较，指出了它们的适用场景和注意事项。&lt;/p&gt;
&lt;p&gt;在实际应用中，我们应该根据具体场景选择合适的智能指针类型，并注意避免智能指针的陷阱，如循环引用和多线程环境下的竞争问题。同时，我们还可以利用智能指针的一些高级用法和技巧，如自定义删除器和指针转换操作等。总之，智能指针是 C++中一个非常实用的工具，能够帮助我们更加高效地管理内存和资源。&lt;/p&gt;
&lt;h2&gt;术语&lt;/h2&gt;
&lt;p&gt;RAII（Resource Acquisition Is Initialization）是一种 C++编程技术，它利用对象的生命周期来管理资源，包括内存、文件、网络连接等。智能指针就是利用 RAII 技术来管理内存资源的一种实现。&lt;/p&gt;
&lt;p&gt;RAII 技术的基本原则是：在构造函数中获取资源，在析构函数中释放资源。智能指针通过在析构函数中释放资源，实现了自动管理内存资源的功能。&lt;/p&gt;
&lt;h2&gt;参考&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://learn.microsoft.com/en-us/cpp/cpp/smart-pointers-modern-cpp?view=msvc-170&quot;&gt;https://learn.microsoft.com/en-us/cpp/cpp/smart-pointers-modern-cpp?view=msvc-170&lt;/a&gt;&lt;/p&gt;
</content:encoded></item><item><title>PGP工作原理详解</title><link>https://smj.im/blag/posts/how-pgp-works/</link><guid isPermaLink="true">https://smj.im/blag/posts/how-pgp-works/</guid><description>PGP是什么，它的工作原理及应用场景是什么？本文对此进行了详细的解释。</description><pubDate>Sat, 18 Feb 2023 07:59:25 GMT</pubDate><content:encoded>&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;最近在浏览&lt;a href=&quot;https://www.stephendiehl.com/blog/disconnect.html&quot;&gt;博客&lt;/a&gt;的时候发现博主的 PGP Key 页面，虽然之前知道是用于邮件通信加密的，但是具体原理及使用却不太清楚，所以找了时间查阅了相关资料，整理一下 PGP 加密的一些内容。&lt;/p&gt;
&lt;h2&gt;PGP 定义&lt;/h2&gt;
&lt;p&gt;Pretty Good Privacy（PGP）是一个&lt;a href=&quot;https://en.wikipedia.org/wiki/Encryption_software&quot;&gt;加密程序&lt;/a&gt;，为&lt;a href=&quot;https://en.wikipedia.org/wiki/Data_communication&quot;&gt;数据通信&lt;/a&gt;提供&lt;a href=&quot;https://en.wikipedia.org/wiki/Cryptographic&quot;&gt;加密&lt;/a&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Privacy&quot;&gt;隐私&lt;/a&gt;和&lt;a href=&quot;https://en.wikipedia.org/wiki/Authentication&quot;&gt;身份验证&lt;/a&gt;。PGP 用于对文本、电子邮件、文件、目录和整个磁盘分区进行签名、加密和解密，并提高电子邮件通信的安全性。PGP 加密使用&lt;a href=&quot;https://en.wikipedia.org/wiki/Cryptographic_hash_function&quot;&gt;散列&lt;/a&gt;，&lt;a href=&quot;https://en.wikipedia.org/wiki/Data_compression&quot;&gt;数据压缩&lt;/a&gt;，&lt;a href=&quot;https://en.wikipedia.org/wiki/Symmetric-key_cryptography&quot;&gt;对称密钥加密&lt;/a&gt;，最后是&lt;a href=&quot;https://en.wikipedia.org/wiki/Public-key_cryptography&quot;&gt;公钥加密&lt;/a&gt;的串行组合。其中最关键的是两种形式的加密的组合：对称密钥加密(Symmetric Cryptography)和非对称密钥加密(Asymmetric cryptography)。&lt;/p&gt;
&lt;h2&gt;PGP 工作原理&lt;/h2&gt;
&lt;p&gt;在实现 PGP 加密的过程中，首先使用对称密钥加密算法对原始数据进行加密。对称密钥加密算法包括 DES、AES、Blowfish 等，这些算法能够快速地加密和解密数据，但是需要发送方和接收方之间共享密钥。&lt;/p&gt;
&lt;p&gt;为了避免在网络上传输密钥，PGP 使用了公钥加密算法。公钥加密算法是一种使用不同的密钥加密和解密的算法，其中公钥用于加密，而私钥用于解密。公钥加密算法包括 RSA、DSA 等，这些算法具有极高的安全性，但是加密和解密速度比对称密钥加密算法慢得多。&lt;/p&gt;
&lt;p&gt;PGP 将对称密钥加密，并使用接收方的公钥进行加密。这种方式可以保证密钥的安全性，同时可以确保只有接收方可以解密对称密钥，从而保护了数据的机密性。接收方使用自己的私钥对加密的对称密钥进行解密，然后使用对称密钥对数据进行解密。这种方式既可以保护数据的安全性，也可以提高加解密的速度。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pichost.netlify.app/blog/65603a055a421.webp&quot; alt=&quot;PGP工作原理示意&quot; /&gt;&lt;/p&gt;
&lt;p&gt;PGP 使用两种类型的加密算法来保护数据：对称密钥加密和公钥加密。对称密钥加密是一种使用相同密钥加密和解密的算法，因此在加密和解密之间需要共享密钥。而公钥加密则是一种使用不同的密钥加密和解密的算法，其中公钥用于加密，而私钥用于解密。下面我将简单介绍一下这两种算法的工作原理。&lt;/p&gt;
&lt;h3&gt;对称密钥加密&lt;/h3&gt;
&lt;p&gt;对称密钥加密是一种使用相同密钥加密和解密的算法，因此在加密和解密之间需要共享密钥。对称密钥加密的过程如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;发送方选择一个加密密钥，并使用它将原始数据加密。&lt;/li&gt;
&lt;li&gt;加密后的数据被发送到接收方。&lt;/li&gt;
&lt;li&gt;接收方使用相同的密钥将加密的数据解密。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;尽管对称密钥加密非常高效，但它有一个明显的缺点，即需要在发送方和接收方之间共享密钥。如果这个密钥被黑客或其他人获取，数据将无法得到保护。为了解决这个问题，PGP 使用了另一种加密算法：公钥加密。&lt;/p&gt;
&lt;h3&gt;公钥加密&lt;/h3&gt;
&lt;p&gt;公钥加密是一种使用不同的密钥加密和解密的算法，其中公钥用于加密，而私钥用于解密。公钥加密的过程如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;发送方获取接收方的公钥，并使用它将对称密钥加密。&lt;/li&gt;
&lt;li&gt;加密后的对称密钥和加密后的数据被发送到接收方。&lt;/li&gt;
&lt;li&gt;接收方使用自己的私钥将加密的对称密钥解密。&lt;/li&gt;
&lt;li&gt;接收方使用解密后的对称密钥将加密的数据解密。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;公钥加密允许发送方使用接收方的公钥加密数据，而无需共享对称密钥。这样，即使黑客获得了加密后的数据，也无法使用它，因为他们没有接收方的私钥来解密对称密钥。&lt;/p&gt;
&lt;h3&gt;PGP 示例&lt;/h3&gt;
&lt;p&gt;我用常用的加密电子邮件来举个例子，具体的工作流程是：&lt;/p&gt;
&lt;p&gt;用户 A 要给用户 B 发送邮件。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;用户 B 生成一对密钥（公钥和私钥），将公钥发送给用户 A。&lt;/li&gt;
&lt;li&gt;PGP 软件使用算法生成一个随机的会话密钥，这个密钥是一个很大的数字，而且只使用一次。&lt;/li&gt;
&lt;li&gt;用户 A 用刚刚生成的密钥，加密邮件，并使用用户 B 的公钥对该密钥进行加密。&lt;/li&gt;
&lt;li&gt;最后，用户 A 将加密的邮件及密钥发送给用户 B，用户 B 使用自己的私钥进行解密，得到会话密钥，进而可以解密完整的邮件。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;PGP 加密用途&lt;/h2&gt;
&lt;p&gt;PGP 有三个主要用途：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;发送和接收加密电子邮件。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;验证向您发送此消息的人员的身份，即&lt;strong&gt;数字签名验证&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;加密数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其中，发送安全电子邮件 - 是迄今为止 PGP 的主要应用。数字签名是一种基于公钥加密的技术，用于证明信息的发送者身份和信息完整性，以及防止信息被篡改。发送方使用自己的私钥对消息的摘要进行加密，生成数字签名。接收方使用发送方的公钥对数字签名进行解密，并生成消息的摘要，比对两个摘要是否一致，来验证消息的完整性和身份。如果数字签名验证失败，则说明消息可能被篡改或者来自伪造的发送方。&lt;/p&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;PGP 使用对称密钥加密算法保护数据机密性，使用公钥加密算法保护对称密钥的安全性，使用数字签名技术验证消息的完整性和身份。这种结合了对称密钥和公钥加密的方法，可以在安全性和效率之间取得平衡。PGP 已经成为一种被广泛应用的数据加密和数字签名的标准，保护了用户的隐私和安全。&lt;/p&gt;
&lt;h2&gt;Reference&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Pretty_Good_Privacy&quot;&gt;Pretty Good Privacy - Wikipedia&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.varonis.com/blog/pgp-encryption/&quot;&gt;What is PGP Encryption and How Does It Work? | Varonis&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://hackernoon.com/public-key-cryptography-simply-explained-e932e3093046&quot;&gt;Public Key Cryptography Simply Explained | Hacker Noon&lt;/a&gt;&lt;/p&gt;
</content:encoded></item><item><title>如何恢复Windows EFI分区(UPDATED on 08-10)</title><link>https://smj.im/blag/posts/restore-windows-efi-partion/</link><guid isPermaLink="true">https://smj.im/blag/posts/restore-windows-efi-partion/</guid><pubDate>Wed, 08 Feb 2023 11:03:34 GMT</pubDate><content:encoded>&lt;p&gt;最近在电脑上安装了最新的 Arch Linux，这次不同于之前，使用了 Gnome 的桌面环境，用起来还不错，所以就按照我之前的配置文件，光速配置了一下电脑。然而当我配置 Windows 双启动的时候，却找不到 Windows 的 EFI 分区了，很奇怪，我的两个系统安装在两个硬盘里，所以不存在我误操作删除 EFI 分区的问题。而且我在 Linux 系统还能挂载 Windows 的数据，数据也没有丢失。&lt;/p&gt;
&lt;p&gt;然后我尝试搜索问题出现的原因，没找到，不过却找到了解决方案，方法倒是不是特别难，用到了一个 Windows 的&lt;a href=&quot;https://docs.microsoft.com/en-us/windows-hardware/manufacture/desktop/bcdboot-command-line-options-techref-di&quot;&gt;bcdboot&lt;/a&gt;命令，这里记录一下。&lt;/p&gt;
&lt;h2&gt;操作流程&lt;/h2&gt;
&lt;p&gt;第一步，准备一个 Windows 的安装介质，推荐使用&lt;a href=&quot;https://www.ventoy.net/&quot;&gt;Ventoy&lt;/a&gt;，开源免费，甚至不用格式化 U 盘！！&lt;/p&gt;
&lt;p&gt;第二步，boot 进 live 安装系统，依次点击&lt;code&gt;Repair Computer &amp;gt; Troubleshoot &amp;gt; Advanced &amp;gt; Command Prompt&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;第三步，进入命令提示符后，使用以下命令显示分区：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ diskpart // 运行diskpart
diskpart&amp;gt; list disk  // 列出所有硬盘，每个硬盘都有一个编号（e.g. 0/1/2）
diskpart&amp;gt; sel disk &amp;lt;disk_id&amp;gt; // 选择Windows系统EFI分区所在的硬盘，如果不存在，则需要手动创建，具体下方`UPDATED`的详细说明
diskpart&amp;gt; list partition // 列出所有分区
diskpart&amp;gt; sel partition &amp;lt;id&amp;gt; // 选择EFI分区
diskpart&amp;gt; assign letter=F // 分配EFI一个新盘符
diskpart&amp;gt; exit //退出
$ bcdboot C:\Windows /s F: /f ALL // 创建所有Windows boot files到F盘
$ reboot //重启即可正常进入Windows
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;额外操作&lt;/h2&gt;
&lt;p&gt;UPDATED：&lt;/p&gt;
&lt;p&gt;最近因为某种情况，Windows 启动项又消失了，这次甚至连 EFI 分区都没有了，所以又折腾了很久，这里再更新一下。
如果出现 EFI 分区直接消失的情况，可以通过重建 EFI 分区来解决，以下是具体操作步骤：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 创建EFI类型的新分区
diskpart&amp;gt; create partition efi size=100
// 格式化
diskpart&amp;gt; format quick fs=fat32 label=&quot;System&quot;
//分配卷标
diskpart&amp;gt; assign letter=L
diskpart&amp;gt; exit
X:Resources&amp;gt; bcdboot C:\Windows /s F: /f UEFI
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果最后提示以下内容，说明成功创建：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Boot files successfully created.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;此时退出 CMD，然后重启电脑，进入 BIOS，应该就能看到 Windows 的启动选项了。&lt;/p&gt;
&lt;p&gt;p.s. 有的时候，这里分配给 Windows 的系统分区的 letter 可能不是&lt;code&gt;C&lt;/code&gt;，你要自己确认一下，可以使用&lt;code&gt;list partition&lt;/code&gt;命令来查看具体在哪个分区（一般都有 label，比如&lt;code&gt;系统&lt;/code&gt;或者&lt;code&gt;OS&lt;/code&gt;之类的），确认之后，再执行上面的&lt;code&gt;bcdboot&lt;/code&gt;，否则会创建失败。&lt;/p&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;总的来说，EFI 分区消失并不是什么太大问题，恢复起来也不是很麻烦，但是每次出现这个问题就很困扰，我到现在都不知道具体什么原因引起的，猜测应该是跟双系统有关，但是我的双系统在不同的硬盘里，很奇怪。&lt;/p&gt;
</content:encoded></item><item><title>Scaleway IPV6 server 申请及使用攻略</title><link>https://smj.im/blag/posts/scaleway-ipv6-server-use-guide/</link><guid isPermaLink="true">https://smj.im/blag/posts/scaleway-ipv6-server-use-guide/</guid><pubDate>Fri, 03 Feb 2023 02:45:13 GMT</pubDate><content:encoded>&lt;p&gt;前段时间偶然发现了 scaleway 这个服务商，它提供了一个 ipv6 服务器(1C1M)，一个月只要 0.4 欧，一年换算下来才 30 多 RMB。简直不要太划算，所以就立马着手进行操作，这里记录一下操作流程。&lt;/p&gt;
&lt;h2&gt;需求条件&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;一台能够接入 ipv6 网络的电脑&lt;/p&gt;
&lt;p&gt;一个 cloudflare 账号&lt;/p&gt;
&lt;p&gt;一个 scaleway 账号（注册时需要支持外币的信用卡）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;由于我的家用网络没有 ipv6（刚开始不知道没有 ipv6，一直失败给我整麻了），所以我是用一台支持 ipv6 的服务器作为跳板来进行操作的。&lt;/p&gt;
&lt;h2&gt;下载命令行工具&lt;/h2&gt;
&lt;p&gt;使用 scaleway 官方 api 进行服务器相关操作&lt;/p&gt;
&lt;p&gt;下载命令行工具&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;wget https://github.com/scaleway/scaleway-cli/releases/download/v2.10.0/scaleway-cli_2.10.0_linux_amd64 -O /usr/local/bin/scw
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;赋予可执行权限&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;chmod +x /usr/local/bin/scw
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;生成 ssh 密钥对（optional）&lt;/p&gt;
&lt;p&gt;如果你已经有了密钥对，可以不用再申请&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ssh-keygen -t ed25519 -C &quot;ipv6 test&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;测试是否安装成功&lt;/p&gt;
&lt;p&gt;执行以下命令，若无错误提示即成功&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;scw -h
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;API key 申请&lt;/h2&gt;
&lt;p&gt;我们需要申请一个 API 密钥用来在命令行登陆验证账号&lt;/p&gt;
&lt;p&gt;浏览器打开 &lt;a href=&quot;https://console.scaleway.com/project/credentials&quot;&gt;https://console.scaleway.com/project/credentials&lt;/a&gt;，如图点击按钮申请&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pichost.netlify.app/blog/6560378d96139.webp&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;p&gt;然后输入用途描述，可以随便写&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pichost.netlify.app/blog/6560376ceda8c.webp&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;p&gt;点击生成之后会出现下面的窗口，复制其中的&lt;code&gt;Secret Key&lt;/code&gt;字段（注意这个字段只出现一次，如果忘记需要重新申请），点击&lt;code&gt;OK&lt;/code&gt;即可。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pichost.netlify.app/blog/6560372573940.webp&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;初始化配置&lt;/h2&gt;
&lt;p&gt;执行&lt;code&gt;scw init&lt;/code&gt;初始化设置&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;root@Cloud:~# scw init

                                   @@@@@@@@@@@@@@@.
                                 @@@@@@@@@@@@@@@@@@@@        __          __  _
                                 @@@               @@@@      \ \        / / | |
                                 @@@    @@@@@@@     .@@@      \ \  /\  / /__| | ___ ___  _ __ ___   ___
                                 @@@   @@@@@@@@      @@@       \ \/  \/ / _ \ |/ __/ _ \| &apos;_ ` _ \ / _ \
                                 @@@   @@@           @@@        \  /\  /  __/ | (_| (_) | | | | | |  __/
                                 @@@   @@@     @@@   @@@         \/  \/ \___|_|\___\___/|_| |_| |_|\___|
                                 @@@   @@@     @@@   @@@                                         _  _
                                 @@@           @@@   @@@                                        | |(_)
                                 @@@      .@@@@@@@   @@@             ___   ___ __      __   ___ | | _
                                 @@@      @@@@@@@    @@@            / __| / __|\ \ /\ / /  / __|| || |
                                  @@@.               @@@            \__ \| (__  \ V  V /  | (__ | || |
                                   @@@@@@.         .@@@@            |___/ \___|  \_/\_/    \___||_||_|
                                      @@@@@@@@@@@@@@@@.

------------------------------------------------------------------------------------------------------------------------------------------

Enter a valid secret-key:  xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx

To improve this tool we rely on diagnostic and usage data.
Sending such data is optional and can be disabled at any time by running &quot;scw config set send-telemetry=false&quot;.
Do you want to send usage statistics and diagnostics? (Y/n): n

To fully enjoy Scaleway CLI we recommend you install autocomplete support in your shell.
Do you want to install autocomplete? (Y/n): n
Creating new config at /root/.config/scw/config.yaml
Config saved at /root/.config/scw/config.yaml:
access_key: SCWHDEBGKTK0J4A13FV8
secret_key: xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx
default_organization_id: 00000000-0000-0000-0000-000000000000
default_project_id: xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx
default_region: fr-par
default_zone: fr-par-1

An SSH key is required if you want to connect to a server. More info at https://www.scaleway.com/en/docs/configure-new-ssh-key
We found an SSH key in ~/.ssh/id_ed25519.pub. Do you want to add it to your Scaleway account? (Y/n): Y

✅ Initialization completed with success.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;按照提示输入生成的 API 密钥/是否同意分析匿名数据/是否安装命令行自动补全，根据需求输入&lt;code&gt;Y&lt;/code&gt;/&lt;code&gt;N&lt;/code&gt;就行，至于最后一步是否添加 SSH key 到账户，建议选择&lt;code&gt;Y&lt;/code&gt;，否则需要自己手动在&lt;a href=&quot;https://console.scaleway.com/project/credentials&quot;&gt;网页控制台&lt;/a&gt;添加。&lt;/p&gt;
&lt;p&gt;到这里所有的账户配置就已经完成了，接下来就是申请服务器了，这个就很简单了。&lt;/p&gt;
&lt;h2&gt;申请服务器&lt;/h2&gt;
&lt;p&gt;建议申请荷兰的服务器，法国的很难申请，要看运气。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;scw instance server create type=STARDUST1-S zone=nl-ams-1 image=debian_bullseye root-volume=l:10G name=Debian ip=none ipv6=true project-id=8c2b7b55-a411-4720-8f40-204bb89aa557
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里会提示一串服务器相关信息，无论你是否申请成功。&lt;/p&gt;
&lt;p&gt;执行下面的命令测试是否安装成功&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;root@cloud:~# scw instance server list zone=nl-ams-1
ID                                    NAME    TYPE         STATE    ZONE      PUBLIC IP  PRIVATE IP   TAGS  IMAGE NAME
xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx  Debian  STARDUST1-S  running  nl-ams-1  -          10.19.68.73  []    Debian Bullseye
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果状态是 starting，稍等几秒再执行一次。&lt;/p&gt;
&lt;p&gt;如果状态是 running，说明安装成功。&lt;/p&gt;
&lt;p&gt;如果状态是 archived，说明创建失败，删除然后重新申请即可。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ssh-keygen -t ed25519

scw init

6d40b8e5-2797-4527-b8ce-2a2cfc41ad18

scw instance server create type=STARDUST1-S zone=nl-ams-1 image=debian_bullseye root-volume=l:10G name=Debian ip=none ipv6=true project-id=8c2b7b55-a411-4720-8f40-204bb89aa557

scw instance server create type=STARDUST1-S zone=fr-par-1 image=debian_bullseye root-volume=l:10G name=Debian ip=none ipv6=true project-id=8c2b7b55-a411-4720-8f40-204bb89aa557
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;配置服务器&lt;/h2&gt;
&lt;h3&gt;ssh 连接服务器&lt;/h3&gt;
&lt;p&gt;服务器的 ipv6 地址可以在网页控制台查看，与一般服务器连接不一样的是，scaleway 的服务器只支持使用 public key 来进行验证登陆，不支持密码登陆。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;root@cloud:~# ssh-agent bash
root@cloud:~# ssh-add
Enter passphrase for /root/.ssh/id_ed25519:
Identity added: /root/.ssh/id_ed25519 (root@racknerd-07bcb2)
root@cloud:~# ssh root@&amp;lt;ipv6 address&amp;gt;
Linux Debian 5.10.0-20-cloud-amd64 #1 SMP Debian 5.10.158-2 (2022-12-13) x86_64

The programs included with the Debian GNU/Linux system are free software;
the exact distribution terms for each program are described in the
individual files in /usr/share/doc/*/copyright.

Debian GNU/Linux comes with ABSOLUTELY NO WARRANTY, to the extent
permitted by applicable law.
root@Debian:~#
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;使用 WARP 获取 ipv4&lt;/h3&gt;
&lt;p&gt;这里我是用的开源脚本进行安装配置的，使用起来很简单&lt;/p&gt;
&lt;p&gt;运行安装脚本 按照提示操作即可&lt;/p&gt;
&lt;p&gt;&amp;lt;details&amp;gt;
&amp;lt;summary&amp;gt;安装过程(较长)&amp;lt;/summary&amp;gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;root@Debian:~# wget -N https://raw.githubusercontent.com/fscarmen/warp/main/menu.sh &amp;amp;&amp;amp; bash menu.sh
 Language:
 1. English (default)
 2. 简体中文

 Choose: 2

 所有依赖已存在，不需要额外安装

 检查环境中……
 本项目专为 VPS 添加 wgcf 网络接口，详细说明: [https://github.com/fscarmen/warp]
 脚本特点:
         • 支持 WARP+ 账户，附带第三方刷 WARP+ 流量和升级内核 BBR 脚本
         • 普通用户友好的菜单，进阶者通过后缀选项快速搭建
         • 智能判断操作系统: Ubuntu 、Debian 、CentOS、 Alpine 和 Arch Linux，请务必选择 LTS 系统
         • 支持硬件结构类型: AMD、 ARM 和 s390x
         • 结合 Linux 版本和虚拟化方式，自动优选4个 WireGuard 方案。网络性能方面: 内核集成 WireGuard &amp;gt; 安 装内核模块 &amp;gt; wireguard-go
         • 智能判断 WGCF 作者 github库的最新版本 （Latest release）
         • 支持 WARP Linux Socks5 Client
         • 输出执行结果，提示是否使用 WARP IP ，IP 归属地和线路提供商

======================================================================================================================

 脚本版本:2.46   功能新增:通过 [warp s 4/6/d] 来切换 IPv4 / IPv6 的优先级别
 系统信息:
         当前操作系统:Debian GNU/Linux 11 (bullseye)
         内核:5.10.0-20-cloud-amd64
         处理器架构:amd64
         虚拟化:kvm
         IPv4:
         IPv6: 2001:bc8:1830:224::1    Scaleway
         WARP 网络接口未开启
         Client 未安装
         WireProxy 未安装

======================================================================================================================

 1.  为 NAT IPv4 添加 WARP IPv4 网络接口 (bash menu.sh 4)
 2.  为 NAT IPv4 添加 WARP IPv6 网络接口 (bash menu.sh 6)
 3.  为 NAT IPv4 添加 WARP 双栈网络接口 (bash menu.sh d)
 4.  打开 WARP (warp o)
 5.  安装 CloudFlare Client 并设置为 Proxy 模式 (bash menu.sh c)
 6.  更换支持 Netflix 的 IP (warp i)
 7.  永久关闭 WARP 网络接口，并删除 WARP、 Linux Client 和 WireProxy (warp u)
 8.  刷 WARP+ 流量 (warp p)
 9.  升级内核、安装BBR、DD脚本 (warp b)
 10. 同步最新版本 (warp v)
 11. WARP 解锁 Netflix 等流媒体专业一键(支持多平台、多方式和 TG 通知)
 12. 安装 iptable + dnsmasq + ipset，让 WARP IPv4 only 接管流媒体流量 (不适用于 IPv6 only VPS) (bash menu.sh e)
 13. 安装 wireproxy，让 WARP 在本地创建一个 socks5 代理 (bash menu.sh w)
 14. 安装 CloudFlare Client 并设置为 WARP 模式 (bash menu.sh l)
 0.  退出脚本

 请选择: 3

 如有 WARP+ 或 Teams 账户请选择
 1. 使用免费账户 (默认)
 2. WARP+
 3. Teams

 请选择: 1

 请选择优先级别:
 1. IPv4
 2. IPv6
 3. 使用 VPS 初始设置 (默认)

 请选择: 3

 进度 1/3: 安装系统依赖……

--2023-02-03 07:45:30--  https://github.com/ViRb3/wgcf/releases/download/v2.2.15/wgcf_2.2.15_linux_amd64
Resolving github.com (github.com)... failed: No address associated with hostname.
wget: unable to resolve host address ‘github.com’
--2023-02-03 07:45:30--  https://raw.githubusercontent.com/fscarmen/warp/main/wgcf/wgcf_2.2.15_linux_amd64
Resolving raw.githubusercontent.com (raw.githubusercontent.com)... 2606:50c0:8000::154, 2606:50c0:8001::154, 2606:50c0:8002::154, ...
Connecting to raw.githubusercontent.com (raw.githubusercontent.com)|2606:50c0:8000::154|:443... connected.
Hit:1 http://ppa.launchpad.net/scaleway/stable/ubuntu focal InRelease
Get:2 https://dl.cloudsmith.io/public/caddy/stable/deb/debian any-version InRelease [7,505 B]
Hit:3 http://security.debian.org/debian-security bullseye-security InRelease
Hit:4 http://deb.debian.org/debian bullseye InRelease
Hit:5 http://deb.debian.org/debian bullseye-updates InRelease
0% [Waiting for headers]200 OK
Length: 8687616 (8.3M) [application/octet-stream]
Saving to: ‘/usr/bin/wgcf’

/usr/bin/wgcf              100%[======================================&amp;gt;]   8.29M  --.-KB/s    in 0.04s

2023-02-03 07:45:31 (196 MB/s) - ‘/usr/bin/wgcf’ saved [8687616/8687616]

Hit:6 http://deb.debian.org/debian bullseye-backports InRelease
Fetched 7,505 B in 1s (9,123 B/s)
Reading package lists... Done
Building dependency tree... Done
Reading state information... Done
7 packages can be upgraded. Run &apos;apt list --upgradable&apos; to see them.
W: Target Packages (main/binary-amd64/Packages) is configured multiple times in /etc/apt/sources.list:7 and /etc/apt/sources.list.d/backports.list:1
W: Target Packages (main/binary-all/Packages) is configured multiple times in /etc/apt/sources.list:7 and /etc/apt/sources.list.d/backports.list:1
W: Target Translations (main/i18n/Translation-en_US) is configured multiple times in /etc/apt/sources.list:7 and /etc/apt/sources.list.d/backports.list:1
W: Target Translations (main/i18n/Translation-en) is configured multiple times in /etc/apt/sources.list:7 and /etc/apt/sources.list.d/backports.list:1
W: Target Packages (main/binary-amd64/Packages) is configured multiple times in /etc/apt/sources.list:7 and /etc/apt/sources.list.d/backports.list:1
W: Target Packages (main/binary-all/Packages) is configured multiple times in /etc/apt/sources.list:7 and /etc/apt/sources.list.d/backports.list:1
W: Target Translations (main/i18n/Translation-en_US) is configured multiple times in /etc/apt/sources.list:7 and /etc/apt/sources.list.d/backports.list:1
W: Target Translations (main/i18n/Translation-en) is configured multiple times in /etc/apt/sources.list:7 and /etc/apt/sources.list.d/backports.list:1
Reading package lists... Done
Building dependency tree... Done
Reading state information... Done
iptables is already the newest version (1.8.7-1).
net-tools is already the newest version (1.60+git20181103.0eebece-1).
net-tools set to manually installed.
The following packages will be REMOVED:
  resolvconf
The following NEW packages will be installed:
  bind9-dnsutils dnsutils openresolv
The following packages will be upgraded:
  bind9-libs
1 upgraded, 3 newly installed, 1 to remove and 6 not upgraded.
Need to get 2,120 kB of archives.
After this operation, 975 kB of additional disk space will be used.
Get:1 http://deb.debian.org/debian bullseye/main amd64 openresolv all 3.12.0-1 [25.4 kB]
Get:2 http://security.debian.org/debian-security bullseye-security/main amd64 bind9-libs amd64 1:9.16.37-1~deb11u1 [1,424 kB]
Get:3 http://security.debian.org/debian-security bullseye-security/main amd64 bind9-dnsutils amd64 1:9.16.37-1~deb11u1 [404 kB]
Get:4 http://security.debian.org/debian-security bullseye-security/main amd64 dnsutils all 1:9.16.37-1~deb11u1 [267 kB]
Fetched 2,120 kB in 1s (1,920 kB/s)
apt-listchanges: Reading changelogs...
(Reading database ... 34802 files and directories currently installed.)
Removing resolvconf (1.87) ...

 进度 2/3: 已安装 WGCF

                       resolvconf.postrm: Reboot recommended
(Reading database ... 34785 files and directories currently installed.)
Preparing to unpack .../bind9-libs_1%3a9.16.37-1~deb11u1_amd64.deb ...
Unpacking bind9-libs:amd64 (1:9.16.37-1~deb11u1) over (1:9.16.33-1~deb11u1) ...
Selecting previously unselected package bind9-dnsutils.
Preparing to unpack .../bind9-dnsutils_1%3a9.16.37-1~deb11u1_amd64.deb ...
Unpacking bind9-dnsutils (1:9.16.37-1~deb11u1) ...
Selecting previously unselected package dnsutils.
Preparing to unpack .../dnsutils_1%3a9.16.37-1~deb11u1_all.deb ...
Unpacking dnsutils (1:9.16.37-1~deb11u1) ...
Selecting previously unselected package openresolv.
Preparing to unpack .../openresolv_3.12.0-1_all.deb ...
Unpacking openresolv (3.12.0-1) ...
Setting up bind9-libs:amd64 (1:9.16.37-1~deb11u1) ...
Setting up openresolv (3.12.0-1) ...
Installing new version of config file /etc/dhcp/dhclient-enter-hooks.d/resolvconf ...
Installing new version of config file /etc/network/if-down.d/resolvconf ...
Installing new version of config file /etc/network/if-up.d/000resolvconf ...
Installing new version of config file /etc/ppp/ip-down.d/000resolvconf ...
Installing new version of config file /etc/ppp/ip-up.d/000resolvconf ...
Setting up bind9-dnsutils (1:9.16.37-1~deb11u1) ...
Setting up dnsutils (1:9.16.37-1~deb11u1) ...
Processing triggers for libc-bin (2.31-13+deb11u5) ...
Processing triggers for man-db (2.9.4-2) ...
Reading package lists... Done
Building dependency tree... Done
Reading state information... Done
The following NEW packages will be installed:
  wireguard-tools
0 upgraded, 1 newly installed, 0 to remove and 6 not upgraded.
Need to get 86.2 kB of archives.
After this operation, 327 kB of additional disk space will be used.
Get:1 http://deb.debian.org/debian bullseye/main amd64 wireguard-tools amd64 1.0.20210223-1 [86.2 kB]
Fetched 86.2 kB in 0s (196 kB/s)
Selecting previously unselected package wireguard-tools.
(Reading database ... 34824 files and directories currently installed.)
Preparing to unpack .../wireguard-tools_1.0.20210223-1_amd64.deb ...
Unpacking wireguard-tools (1.0.20210223-1) ...
Setting up wireguard-tools (1.0.20210223-1) ...
wg-quick.target is a disabled or a static unit, not starting it.
Processing triggers for man-db (2.9.4-2) ...
 创建快捷 warp 指令成功
 运行 WARP
 后台获取 WARP IP 中,最大尝试5次……
 第1次尝试
 已成功获取 WARP 网络

==============================================================

 IPv4: 104.28.219.140 ( WARP IPv4 ) 荷兰  Cloudflare
 IPv6: 2a09:bac1:5540::14:2a2 ( WARP IPv6 ) 荷兰  Cloudflare
 恭喜！WARP 已开启，总耗时:33秒， 脚本当天运行次数:1100，累计运行次数:2032952
 IPv6 优先

==============================================================

 再次运行用 warp [option] [lisence]，如

 warp h (帮助菜单）
 warp n (获取 WARP IP)
 warp o (临时warp开关)
 warp u (卸载 WARP 网络接口和 Socks5 Client)
 warp b (升级内核、开启BBR及DD)
 warp a (更换账户为 Free，WARP+ 或 Teams)
 warp p (刷WARP+流量)
 warp v (同步脚本至最新版本)
 warp r (WARP Linux Client 开关)
 warp 4/6 (WARP IPv4/IPv6 单栈)
 warp d (WARP 双栈)
 warp c (安装 WARP Linux Client，开启 Socks5 代理模式)
 warp l (安装 WARP Linux Client，开启 WARP 模式)
 warp i (更换支持 Netflix 的IP)
 warp e (安装 Iptables + dnsmasq + ipset 解决方案)
 warp w (安装 WireProxy 解决方案)
 warp y (WireProxy socks5 开关)
 warp s 4/6/d (优先级: IPv4 / IPv6 / VPS default)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&amp;lt;/details&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;br&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;details&amp;gt;
&amp;lt;summary&amp;gt;图示流程&amp;lt;/summary&amp;gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pichost.netlify.app/blog/65603a85b2321.webp&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pichost.netlify.app/blog/65603a8b9ae37.webp&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pichost.netlify.app/blog/65603a8385088.webp&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pichost.netlify.app/blog/65603a882fe64.webp&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pichost.netlify.app/blog/65603a7eebc07.webp&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;/details&amp;gt;&lt;/p&gt;
&lt;h2&gt;测试是否配置成功&lt;/h2&gt;
&lt;p&gt;执行&lt;code&gt;ip addr&lt;/code&gt;，如果出现了一个 wgcf 的网卡，说明配置成功，或者直接执行&lt;code&gt;ping -4 google.com&lt;/code&gt;测试能 ping 通。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;root@Debian:~# ping -4 google.com
PING  (142.251.36.14) 56(84) bytes of data.
64 bytes from ams15s44-in-f14.1e100.net (142.251.36.14): icmp_seq=1 ttl=119 time=2.40 ms
64 bytes from ams15s44-in-f14.1e100.net (142.251.36.14): icmp_seq=2 ttl=119 time=2.62 ms
64 bytes from ams15s44-in-f14.1e100.net (142.251.36.14): icmp_seq=3 ttl=119 time=2.78 ms
64 bytes from ams15s44-in-f14.1e100.net (142.251.36.14): icmp_seq=4 ttl=119 time=2.68 ms
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;到这里所有都配置成功了。接下来的使用就和一个普通的服务器没有太大区别了，你可以用来做任何事情，我是用来运行一个没人看的&lt;a href=&quot;https://hyl.im&quot;&gt;博客&lt;/a&gt;，套上 CF 速度感觉还不错:）&lt;/p&gt;
</content:encoded></item><item><title>Arch Linux 升级系统提示签名无效</title><link>https://smj.im/blag/posts/signature-invalid-when-upgrading-archlinux/</link><guid isPermaLink="true">https://smj.im/blag/posts/signature-invalid-when-upgrading-archlinux/</guid><pubDate>Thu, 05 Jan 2023 06:00:01 GMT</pubDate><content:encoded>&lt;p&gt;今天升级系统的时候，竟然升级失败了，提示：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;error: PackageName: signature from &quot;User &amp;lt;email@archlinux.org&amp;gt;&quot; is invalid
error: failed to commit transaction (invalid or corrupted package (PGP signature))
Errors occurred, no packages were upgraded.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我瞬间懵逼了，因为是第一次碰到这个问题，用了这么久，从未出现过这个问题，所以就马上 Google 类似问题
发现是 keyring 的问题，所以就试着直接先更新 keyring&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo pacman -Sy archlinux-keyring
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然而并没有什么卵用，然后在 archlinux 的论坛找到了一个和我完全一样问题的答案，直接重置所有 cache 然后重置&lt;code&gt;pacman-key&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo pacman -Sc
sudo rm -r /etc/pacman.d/gnupg
sudo pacman-key --init
sudo pacman-key --populate
sudo pacman -Sy archlinux-keyring
sudo pacman -Syu
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;reference&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://wiki.archlinux.org/title/Pacman/Package_signing#Troubleshooting&quot;&gt;https://wiki.archlinux.org/title/Pacman/Package_signing#Troubleshooting&lt;/a&gt;&lt;/p&gt;
</content:encoded></item><item><title>Arch Linux音响有杂音的解决办法</title><link>https://smj.im/blag/posts/resolve-noise-issue-in-archlinux/</link><guid isPermaLink="true">https://smj.im/blag/posts/resolve-noise-issue-in-archlinux/</guid><pubDate>Mon, 04 Jul 2022 02:20:22 GMT</pubDate><content:encoded>&lt;blockquote&gt;
&lt;p&gt;Arch Linux 台式机（AMD）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最近安装完新系统之后，在配置电脑的时候发现电脑的音响在不播放声音的时候会出现&lt;code&gt;puta puta&lt;/code&gt;的声音。&lt;/p&gt;
&lt;h3&gt;原因&lt;/h3&gt;
&lt;p&gt;某些驱动模块会在声卡闲置时关闭它以节约用电。&lt;/p&gt;
&lt;h3&gt;解决办法&lt;/h3&gt;
&lt;p&gt;方法 1：&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;/etc/modprobe.d&lt;/code&gt;目录下新建一个&lt;code&gt;disablePowerSaving.conf&lt;/code&gt;文件，写入以下内容&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;options snd_hda_intel power_save=0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;重启电脑应该就可解决，如果还有噪音，可能还需要禁用声卡控制器的省电功能：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;options snd_hda_intel power_save=0 power_save_controller=N
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;方法 2：&lt;/p&gt;
&lt;p&gt;还有另外一种方法，就是添加内核参数：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;modprobe snd_hda_intel power_save=0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我使用的是 GRUB 引导，编辑&lt;code&gt;/etc/default/grub&lt;/code&gt;文件，将上述内容附加在&lt;code&gt;GRUB_CMDLINE_LINUX_DEFAULT&lt;/code&gt;的值后面，然后重新生成 grub 配置：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# grub-mkconfig -o /boot/grub/grub.cfg
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;参考&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://wiki.archlinux.org/title/Advanced_Linux_Sound_Architecture/Troubleshooting#Pops_when_starting_and_stopping_playback&quot;&gt;https://wiki.archlinux.org/title/Advanced_Linux_Sound_Architecture/Troubleshooting#Pops_when_starting_and_stopping_playback&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.kernel.org/sound/designs/powersave.html&quot;&gt;https://docs.kernel.org/sound/designs/powersave.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://bbs.archlinux.org/viewtopic.php?id=267838&quot;&gt;https://bbs.archlinux.org/viewtopic.php?id=267838&lt;/a&gt;&lt;/p&gt;
</content:encoded></item><item><title>Arch Linux 如何切换内核</title><link>https://smj.im/blag/posts/how-to-change-archlinux-kernel/</link><guid isPermaLink="true">https://smj.im/blag/posts/how-to-change-archlinux-kernel/</guid><pubDate>Sun, 08 May 2022 02:14:12 GMT</pubDate><content:encoded>&lt;h2&gt;Notice&lt;/h2&gt;
&lt;p&gt;切换内核不是一件容易的事。我建议你有一个实际的理由这样做，而不仅仅是实验/为了好玩。虽然这本身并不是一个困难的过程。因为 linux 发行版通常设置为与特定内核配合使用。虽然有些不像其他发行版那样与内核紧密相连，但许多发行版维护者选择特定的内核是有原因的。Arch Linux 发行版不像 Ubuntu，RHEL 发行版等那样与特定的内核绑定。所以我使用 ArchLinux 来进行演示。&lt;/p&gt;
&lt;p&gt;这里列举目前 ArchLinux 官方支持的内核：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Stable&lt;/strong&gt; — 原版的 Linux 内核以及模块, 使用了一些补丁。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&quot;https://www.kernel.org/&quot;&gt;https://www.kernel.org/&lt;/a&gt; || linux&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Hardened&lt;/strong&gt; — 更加注重安全的 Linux 内核，采用一系列 &lt;a href=&quot;https://github.com/thestinger/linux-hardened&quot;&gt;加固补丁&lt;/a&gt; 以减少内核和用户空间产生漏洞的风险。和 &lt;a href=&quot;https://archlinux.org/packages/?name=linux&quot;&gt;linux&lt;/a&gt; 相比，还启用了一些加固选项，比如用户命名空间(同时通过补丁禁用未授权用户的访问)、审计以及 &lt;a href=&quot;https://wiki.archlinux.org/title/SELinux&quot;&gt;SELinux&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/anthraxx/linux-hardened&quot;&gt;https://github.com/anthraxx/linux-hardened&lt;/a&gt; || linux-hardened&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Longterm&lt;/strong&gt; — 包含了长期支持的 Linux 内核和内核模块。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&quot;https://www.kernel.org/&quot;&gt;https://www.kernel.org/&lt;/a&gt; || linux-lts&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Zen Kernel&lt;/strong&gt; — 一些内核黑客合作的结果，提供了适合日常使用的优秀内核。 更多详情请参见 &lt;a href=&quot;https://liquorix.net/&quot;&gt;https://liquorix.net&lt;/a&gt; (为 Debian 提供了基于 Zen 内核的二进制文件).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/zen-kernel/zen-kernel&quot;&gt;https://github.com/zen-kernel/zen-kernel&lt;/a&gt; || linux-zen&lt;/p&gt;
&lt;h2&gt;切换内核&lt;/h2&gt;
&lt;h3&gt;Step 1 检查安装的内核和版本&lt;/h3&gt;
&lt;p&gt;首先，使用以下命令检查当前安装的内核和版本：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ uname -r
5.17.5-zen1-1-zen
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看出，我使用的是&lt;code&gt;linux-zen&lt;/code&gt;内核。&lt;/p&gt;
&lt;h3&gt;Step 2 安装新内核&lt;/h3&gt;
&lt;p&gt;然后，选择你需要切换的内核安装，比如说，我们要安装原版 linux 内核：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo pacman -S linux linux-headers
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Step 3 卸载现在使用的内核&lt;/h3&gt;
&lt;p&gt;使用以下命令进行卸载（根据自身情况更改内核名称）：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo pacman -Rs linux-zen linux-zen-headers
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Step 4 更新 boot loader 的配置&lt;/h3&gt;
&lt;p&gt;我使用的是 GRUB，使用以下命令更新：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo grub-mkconfig -o /boot/grub/grub.cfg
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最后，您需要做的就是重新启动系统就可以更新到新的内核。&lt;/p&gt;
&lt;p&gt;只是要切换内核的话，到这里就结束了。但是如果你想在必要的时候，可以很快地使用不同的内核，则只需删除 Step 3 即可。但是，为了切换内核操作方便，我们可以对 GRUB 的配置文件进行一些更改。&lt;/p&gt;
&lt;p&gt;首先，使用编辑器打开&lt;code&gt;/etc/default/grub&lt;/code&gt;文件：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo vim /etc/default/grub
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;接下来，我们将更改以下选项。根据你使用的基于 Arch 的发行版，这些设置可能有不同的顺序，已经正确设置，或者可能需要取消注释。具体根据自身情况确定。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;GRUB_DEFAULT=saved
GRUB_SAVEDEFAULT=true
GRUB_DISABLE_SUBMENU=y

# 含义
# GRUB_DEFAULT — Default boot selection.
# GRUB_SAVEDEFAULT — GRUB to remember the last selection.
# GRUB_DISABLE_SUBMENU — Disable submenus.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;到这里就结束了，现在，我们就可以在 GRUB 引导界面进行内核的选择，而且 GRUB 会默认记住上次的选择，而不需要你每次都要进行选择操作。&lt;/p&gt;
&lt;h2&gt;Reference&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://wiki.archlinux.org/title/Kernel&quot;&gt;https://wiki.archlinux.org/title/Kernel&lt;/a&gt;&lt;a href=&quot;https://medium.com/codex/how-to-switch-your-linux-kernel-in-arch-linux-5a39569161d9&quot;&gt;How to Switch your Linux Kernel in Arch Linux&lt;/a&gt;&lt;/p&gt;
</content:encoded></item><item><title>Django项目时区更改错误的解决方案</title><link>https://smj.im/blag/posts/django-timezone-error-solution/</link><guid isPermaLink="true">https://smj.im/blag/posts/django-timezone-error-solution/</guid><description>记录我在更改时区时踩到的坑和解决方案，以及一点小小的感想。</description><pubDate>Fri, 04 Mar 2022 02:03:26 GMT</pubDate><content:encoded>&lt;h3&gt;&lt;strong&gt;TL;DR&lt;/strong&gt;&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;修改 Django 项目的&lt;code&gt;TIME_ZONE&lt;/code&gt;设置为&lt;code&gt;Asia/Shanghai&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;填充 MySQL 时区表：&lt;code&gt;mysql_tzinfo_to_sql /usr/share/zoneinfo | mysql -u root -p mysql&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;向 MySQL 全局配置文件的&lt;code&gt;mysqld&lt;/code&gt;中添加&lt;code&gt;default-time-zone=&apos;Asia/Shanghai&apos;&lt;/code&gt;；或者在 MySQL shell 中执行&lt;code&gt;SET GLOBAL time_zone = &apos;Asia/Shanghai&apos;;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;向 Django 项目设置中的&lt;code&gt;DATABASES&lt;/code&gt;字段添加时区，并设置为&lt;code&gt;Asia/Shanghai&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;(optional)更新已经存在数据的时间：&lt;code&gt;update blog_article set column_name=DATE_ADD(column_name, INTERVAL 8 HOUR);&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;正文&lt;/h3&gt;
&lt;h3&gt;起因&lt;/h3&gt;
&lt;p&gt;今天在博客迁移服务器之后，突然想起来之前部署的时候，使用的是之前服务器的时区（UTC），没有使用 CST，就想着把时区改一下，不然挺不方便，而且看着挺难受的。修改的时候碰到了一些问题，这里记录一下解决方案以及一些个人感想。&lt;/p&gt;
&lt;h3&gt;尝试&lt;/h3&gt;
&lt;p&gt;最开始，我觉得修改时区应该很简单，直接修改一下 Django 的时区设置即可。然而一个报错直接给我整不会了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pichost.netlify.app/blog/65603a40252d9.webp&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;p&gt;根据错误提示，我推测应该是 MySQL 的时区设置也不对，也要更新一下时区，然后直接在 mysql 配置文件中设置了 CST 时区：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;default-time-zone=&apos;Asia/Shanghai&apos;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;重启 MySQL，竟然失败了？！！！&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Restarting mysql (via systemctl): mysql.serviceJob for mysql.service failed because the control process exited with error code.
See &quot;systemctl status mysql.service&quot; and &quot;journalctl -xe&quot; for details.
 failed!
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;不知道什么原因，这个方法不行，就在网上找到了另一个如何设置 MySQL 时区的&lt;a href=&quot;https://stackoverflow.com/questions/930900/how-do-i-set-the-time-zone-of-mysql&quot;&gt;答案&lt;/a&gt;，发现了另一种解决方法，在 MySQL 的 shell 中更新全局变量&lt;code&gt;@@global.time_zone&lt;/code&gt;。所以删除了之前添加的时区配置，进入 MySQL shell 中进行设置：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SET @@global.time_zone = &apos;+08:00&apos;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后，输出时区设置：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    mysql&amp;gt; SELECT @@global.time_zone;
    +--------------------+
    | @@global.time_zone |
    +--------------------+
    | +08:00             |
    +--------------------+
    1 row in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;感觉设置成功了，然后尝试运行服务，发现还是同样的错误。明明时区设置成功了，为什么不生效呢？&lt;/p&gt;
&lt;h3&gt;答案？&lt;/h3&gt;
&lt;p&gt;然后突然想到一个问题，我直接 Google 报错信息不就行了？果然，立刻就发现了一个&lt;a href=&quot;https://stackoverflow.com/questions/40792628/django-mysql-database-returned-an-invalid-datetime-value&quot;&gt;答案&lt;/a&gt;，直接使用这个命令就能搞定：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql_tzinfo_to_sql /usr/share/zoneinfo | mysql -u root -p mysql
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;动手试了一下，发现还真的可以，只不过会提示一些 Warning 信息：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    Warning: Unable to load &apos;/usr/share/zoneinfo/iso3166.tab&apos; as time zone. Skipping it.
    Warning: Unable to load &apos;/usr/share/zoneinfo/leap-seconds.list&apos; as time zone. Skipping it.
    Warning: Unable to load &apos;/usr/share/zoneinfo/leapseconds&apos; as time zone. Skipping it.
    Warning: Unable to load &apos;/usr/share/zoneinfo/tzdata.zi&apos; as time zone. Skipping it.
    Warning: Unable to load &apos;/usr/share/zoneinfo/zone.tab&apos; as time zone. Skipping it.
    Warning: Unable to load &apos;/usr/share/zoneinfo/zone1970.tab&apos; as time zone. Skipping it.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;问题来了，为什么呢？虽然这样可以，但是不知道原因，心里有点不舒服，所以就查了官方文档。然后在&lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/time-zone-support.html&quot;&gt;这里&lt;/a&gt;中找到了答案：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Several tables in the mysql system schema exist to store time zone information . The MySQL installation procedure creates the time zone tables, but does not load them. To do so manually, use the following instructions.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;根据上面这句话我们可以很容易发现，MySQL 安装过程创建时区表，但不会加载它们，需要我们手动加载。加载方法也很简单，就是我们上面提到的那行命令：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql_tzinfo_to_sql /usr/share/zoneinfo | mysql -u root -p mysql
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中，&lt;code&gt;mysql_tzinfo_to_sql&lt;/code&gt;y 用来读取系统的时区文件并从中生成 SQL 语句。 &lt;code&gt;mysql&lt;/code&gt;y 用来处理这些语句以加载时区表。&lt;/p&gt;
&lt;p&gt;有一点要注意的是，上面的命令会加载&lt;code&gt;/usr/share/zoneinfo&lt;/code&gt;下的所有时区信息，所以如果你不想这样的话，也可以选择加载自己需要的时区，命令的基本格式是：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql_tzinfo_to_sql tz_file tz_name | mysql -u root -p mysql
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;比如：只加载&lt;code&gt;Asia/Shanghai&lt;/code&gt;时区，可以使用下面的命令：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql_tzinfo_to_sql /usr/share/zoneinfo/Asia/Shanghai ‘Asia/Shanghai’ | mysql -u root -p mysql
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在更新时区表后，重新启动&lt;code&gt;mysqld&lt;/code&gt;以确保它不会继续提供过时的时区配置。&lt;/p&gt;
&lt;p&gt;然后在 MySQL shell 中确认一下是否成功：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    mysql&amp;gt; SELECT * FROM mysql.time_zone_name;
    +---------------+--------------+
    | Name          | Time_zone_id |
    +---------------+--------------+
    | Asia/Shanghai |         1    |
    +---------------+--------------+
    1 row in set (0.01 sec)

    mysql&amp;gt; SELECT @@global.time_zone;
    +--------------------+
    | @@global.time_zone |
    +--------------------+
    | Asia/Shanghai      |
    +--------------------+
    1 row in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;更新完 MySQL 时区设置，然后重新进入 admin 界面，时间已经改变成了 CST 时区时间。&lt;/p&gt;
&lt;p&gt;此外，在文档中我还找到了设置时区为&lt;code&gt;Asia/Shanghai&lt;/code&gt;导致 MySQL 启动失败的原因：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Note&lt;/p&gt;
&lt;p&gt;Named time zones can be used only if &lt;strong&gt;the time zone information tables in the&lt;/strong&gt; &lt;code&gt;**mysql**&lt;/code&gt; &lt;strong&gt;database&lt;/strong&gt; have been created and populated. Otherwise, use of a named time zone results in an error:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; SET time_zone = &apos;UTC&apos;;
ERROR 1298 (HY000): Unknown or incorrect time zone: &apos;UTC&apos;
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们从上面的粗体部分可以发现：之前之所以设置&lt;code&gt;Asia/Shanghai&lt;/code&gt;不生效是因为**MySQL 仅当数据库中的时区信息表已创建并填充时，才能使用命名时区。**因为刚开始没有填充时区表，MySQL 不知道 Asia/Shanghai 代表什么意思，所以才会出错无法启动 MySQL 服务。&lt;/p&gt;
&lt;h3&gt;测试&lt;/h3&gt;
&lt;p&gt;尝试创建了一篇文章，发现时间也是对的，感觉到这里应该没什么问题了。但是，有点强迫症的我还是进入 MySQL 查看了一下数据，结果。。。数据库中的时间竟然还是 UTC 时间？？&lt;/p&gt;
&lt;p&gt;虽然还是没有成功，但是现在有一点可以确认的是，MySQL 的配置已经没有了问题，所以失败的原因出在了 Django 配置上。然后直接查看官方文档，在&lt;a href=&quot;https://docs.djangoproject.com/en/4.0/topics/i18n/timezones/&quot;&gt;其中&lt;/a&gt;找到了原因。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;When support for time zones is enabled, Django stores datetime information in UTC in the database, uses time-zone-aware datetime objects internally, and translates them to the end user’s time zone in templates and forms.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;换句话说，只要是项目使用时区支持，那么，无论你设置什么时区，Django 在数据库中存储数据默认都是使用 UTC 时间。所以，如果想要更改 Django 存储数据的时区，还需要在 setting 中的 &lt;code&gt;DATABASES&lt;/code&gt; 里，将&lt;code&gt;TIME_ZONE&lt;/code&gt;选项设置为你想要的时区。&lt;/p&gt;
&lt;p&gt;更新了 Django 项目的配置，然后重新启动，进入 admin 界面，时间没问题，然后进入 MySQL shell 查看时间列，也没问题。终于，终于成功了！！！&lt;/p&gt;
&lt;h3&gt;收尾&lt;/h3&gt;
&lt;p&gt;当然，还有一步，那就是更新 MySQL 数据库中已经存在的数据的时间，这个直接在原来的时间上加 8 小时即可：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;update blog_article set column_name=DATE_ADD(column_name, INTERVAL 8 HOUR);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;想法&lt;/h3&gt;
&lt;p&gt;最后，虽然这只是个小问题，也解决了，但是也让我有点意识到了自己的一些不好的思维方式，本来只需要直接查找一下类似的错误，很快就能找到解决方案。&lt;/p&gt;
</content:encoded></item><item><title>超简单的Arch Linux + Windows双启动教程</title><link>https://smj.im/blag/posts/linux-windows-dual-boot-tutorial/</link><guid isPermaLink="true">https://smj.im/blag/posts/linux-windows-dual-boot-tutorial/</guid><pubDate>Wed, 23 Feb 2022 12:59:03 GMT</pubDate><content:encoded>&lt;blockquote&gt;
&lt;p&gt;OS：Arch Linux + Windows 10&lt;/p&gt;
&lt;p&gt;bootloader：GRUB&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;因为偶尔仍然要使用 Windows 做些事情，之前每次都是通过 GURB 的界面退出操作进行重新选择，很是麻烦，所以就尝试进行配置 Arch Linux+Windows 的双启动。用的工具是 os-prober，操作很简单。&lt;/p&gt;
&lt;p&gt;1、首先安装&lt;code&gt;os-prober&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    [root@archlinux /]# pacman -S os-prober
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2、检查磁盘分区，确认 Windows 的安装位置（根据自己的安装情况选择磁盘设备，我这里是&lt;code&gt;/dev/sda&lt;/code&gt;）：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    [root@archlinux /]# fdisk -l /dev/sda
    Disk /dev/sda: 223.6 GiB, 240057409536 bytes, 468862128 sectors
    Disk model: KINGSTON SA400S3
    Units: sectors of 1 \* 512 = 512 bytes
    Sector size (logical/physical): 512 bytes / 512 bytes
    I/O size (minimum/optimal): 512 bytes / 512 bytes
    Disklabel type: gpt
    Disk identifier: 78241A73-6994-4D0B-9FCB-433076B5EC41

    Device       Start       End   Sectors  Size Type
    /dev/sda1     2048   1023999   1021952  499M Windows recovery environment
    /dev/sda2  1024000   1228799    204800  100M EFI System
    /dev/sda3  1228800   1261567     32768   16M Microsoft reserved
    /dev/sda4  1261568 468860927 467599360  223G Microsoft basic data
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3、找到 Windows 的 EFI 分区之后，挂载它以确保&lt;code&gt;os-prober&lt;/code&gt;可以发现：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    [root@archlinux /]# mount /dev/sda2 /mnt/
    [root@archlinux /]# ls -l /mnt/
    total 1
    drwxr-xr-x 4 root root 1024 Feb 23 10:24 EFI
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;4、然后执行&lt;code&gt;os-prober&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    [root@archlinux /]# os-prober
    /dev/sda2@/EFI/Microsoft/Boot/bootmgfw.efi:Windows Boot Manager:Windows:efi
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;5、当然，为了安全起见，首先执行下面命令，备份原有的 boot 配置：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    [root@archlinux /]# cp /boot/grub/grub.cfg /boot/grub/grub.cfg.bak
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;6、然后，重新生辰 GRUB 配置文件：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    [root@archlinux /]# grub-mkconfig -o /boot/grub/grub.cfg
    Generating grub configuration file ...
    Found linux image: /boot/vmlinuz-linux
    Found initrd image: /boot/initramfs-linux.img
    Found fallback initrd image(s) in /boot: initramfs-linux-fallback.img
    Found Windows Boot Manager on /dev/sda2@/EFI/Microsoft/Boot/bootmgfw.efi
    done
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;7、最后重启电脑就可以在 GRUB 界面直接选择想要进入的操作系统了。&lt;/p&gt;
</content:encoded></item><item><title>使用UFW配置Linux防火墙</title><link>https://smj.im/blag/posts/config-firewall-using-ufw-on-ubuntu-server/</link><guid isPermaLink="true">https://smj.im/blag/posts/config-firewall-using-ufw-on-ubuntu-server/</guid><description>在捣鼓服务器的时候，为了安全考虑，捣鼓了一下ufw。</description><pubDate>Mon, 31 Jan 2022 02:25:02 GMT</pubDate><content:encoded>&lt;p&gt;大部分主流的服务器提供商（腾讯云、阿里云等），防火墙的配置很简单，只要在控制面板设置就行。服务器上设置与否无所谓。但是如果有一台便宜的 VPS，想在上面整点东西，这个时候为了数据安全的因素，就不得不手动配置了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;UFW&lt;/strong&gt; 代表 &lt;strong&gt;Uncomplicated Firewall&lt;/strong&gt; ，是用于管理 &lt;code&gt;iptables&lt;/code&gt;(&lt;code&gt;netfilter&lt;/code&gt;) 防火墙规则的对用户更加友好的前端工具，它是 Ubuntu 的默认防火墙配置工具。&lt;/p&gt;
&lt;h3&gt;列出 UFW 规则&lt;/h3&gt;
&lt;p&gt;您可以通过以下命令检查 UFW 的状态并列出所有规则：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo ufw status
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果未启用 UFW，则会显示：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Status: inactive
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果已经启用，则 UFW 处于活动状态，输出将打印所有活动防火墙规则的列表：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Status: active

To                        Action      From
--                        ------      ----
22/tcp                    ALLOW      Anywhere
22/tcp (v6)                ALLOW      Anywhere (v6)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果想要获得额外信息，可以使用&lt;code&gt;status verbose&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo ufw status verbose
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;输出将包含有关日志记录，默认策略和新配置文件的信息：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Status: active
Logging: on (low)
Default: deny (incoming), allow (outgoing), disabled (routed)
New profiles: skip

To                        Action      From
--                        ------      ----
22/tcp                    ALLOW      Anywhere
22/tcp (v6)                ALLOW      Anywhere (v6)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果想要得到所有活动规则的顺序和 ID，可以使用&lt;code&gt;status numbered&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo ufw status numbered
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;输出则会显示以下内容：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Status: active

     To                         Action      From
     --                         ------      ----
[ 1] 22/tcp                     ALLOW IN    Anywhere
[ 2] 22/tcp (v6)                ALLOW IN    Anywhere (v6)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;添加 UFW 规则&lt;/h3&gt;
&lt;p&gt;添加规则很简单，不过在添加之前，首先确认 UFW 是否开启。&lt;/p&gt;
&lt;p&gt;例如，如果你要添加打开&lt;code&gt;12345&lt;/code&gt;端口的规则，键入以下命令即可：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo ufw allow 12345
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;拒绝：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo ufw deny 12345
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;删除 UFW 规则&lt;/h3&gt;
&lt;p&gt;有两种方法可以删除 UFW 规则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;按规则编号&lt;/li&gt;
&lt;li&gt;按规则格式&lt;/li&gt;
&lt;/ul&gt;
</content:encoded></item><item><title>Git中的一个特殊hash</title><link>https://smj.im/blag/posts/a-special-hash-in-git/</link><guid isPermaLink="true">https://smj.im/blag/posts/a-special-hash-in-git/</guid><description>最近了解了一点Git的内部原理，看到了一个特殊的hash，所以写了这一篇文章来分享自己的看法。</description><pubDate>Sun, 30 Jan 2022 02:23:03 GMT</pubDate><content:encoded>&lt;p&gt;最近了解了一点 Git 的内部原理，看到了一个特殊的 hash，所以写了这一篇文章来分享自己的看法。&lt;/p&gt;
&lt;p&gt;==============&lt;/p&gt;
&lt;p&gt;既然你读这篇文章，那就意味着你应该比较熟悉 Git 的一系列操作，不过，在你使用 Git 的时候，你有没有遇到以下 hash：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;4b825dc642cb6eb9a060e54bf8d69288fbee4904
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可能你会觉得 git 中的每个对象都有一个 hash 值，谁会注意 hash 的数值。确实，没有人会注意。&lt;/p&gt;
&lt;p&gt;但是上面的这个 hash 确实是一个很特别的 hash，接下来就来说明为什么这个 hash 是一个特殊的存在。&lt;/p&gt;
&lt;h2&gt;git 中 hash 从哪里来？&lt;/h2&gt;
&lt;p&gt;每个 git 存储库，即使是空存储库也将包含这段 hash。这可以通过 git show 验证：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    $ git show 4b825dc642cb6eb9a060e54bf8d69288fbee4904
    tree 4b825dc642cb6eb9a060e54bf8d69288fbee4904
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;那么这个 hash 是从哪里来的呢？在这之前我们需要了解一点 Git 的知识：&lt;em&gt;Git 的核心部分是一个简单的键值对数据库（key-value data store）。 你可以向 Git 仓库中插入任意类型的内容，它会返回一个唯一的键，通过该键可以在任意时刻再次取回该内容。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;我们可以使用&lt;code&gt;git hash-object&lt;/code&gt;命令来存储一个对象并获取该对象的键。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    $ echo &apos;test&apos; | git hash-object -w --stdin
    9daeafb9864cf43055ae93beb0afd6c7d144bfa4
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Git 内部存储的数据类似下面这样，其中每个对象都有其对应的 hash 值：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pichost.netlify.app/blog/65603defa70c6.webp&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;ps：如果你仍然好奇，Pro Git 的&lt;/em&gt; &lt;em&gt;&lt;a href=&quot;https://git-scm.com/book/en/v2/Git-Internals-Git-Objects&quot;&gt;Git Internals&lt;/a&gt;&lt;/em&gt; &lt;em&gt;章节有更多详细介绍。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;那么接下来说正题，这个特殊 hash 是如何产生的呢？它实际上是一棵空树的哈希值。可以通过为空字符串的&lt;code&gt;/dev/null&lt;/code&gt;创建对象哈希来验证：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    $ git hash-object -t tree /dev/null
    4b825dc642cb6eb9a060e54bf8d69288fbee4904
    //或者
    $ echo -n &apos;&apos; | git hash-object -t tree --stdin
    4b825dc642cb6eb9a060e54bf8d69288fbee4904
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;空树 hash 的特殊用处&lt;/h2&gt;
&lt;p&gt;空树 hash 可以与&lt;code&gt;git diff&lt;/code&gt;一起使用。例如，如果你想检查目录中的空白错误，您可以使用 &lt;code&gt;--check&lt;/code&gt; 选项并将 HEAD 与空树进行比较：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    $ echo &quot;test  &quot; &amp;gt; readme.md
    $ git add . &amp;amp;&amp;amp; git commit -m &quot;init&quot;
    [master 6d8e897] init
     1 file changed, 1 insertion(+), 3 deletions(-)
    $ git diff $(git hash-object -t tree /dev/null) HEAD --check -- readme.md
    readme.md:1: trailing whitespace.
    +test
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在编写 &lt;code&gt;git hooks&lt;/code&gt; 时，空树 hash 也非常有用。一个相当常见的用法是在使用类似于以下的代码在接受新提交之前验证它们：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    for changed_file in $(git diff --cached --name-only --diff-filter=ACM HEAD)
    do
      if ! validate_file &quot;$changed_file&quot;; then
        echo &quot;Aborting commit&quot;
        exit 1
      fi
    done
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果有以前的提交，这可以正常工作，但是如果没有提交，则 &lt;code&gt;HEAD&lt;/code&gt; 引用将不存在。为了解决这个问题，可以在检查初始提交时使用空树 hash：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    if git rev-parse --verify -q HEAD &amp;gt; /dev/null; then
      against=HEAD
    else
      # Initial commit: diff against an empty tree object
      against=&quot;$(git hash-object -t tree /dev/null)&quot;
    fi

    for changed_file in $(git diff --cached --name-only --diff-filter=ACM &quot;$against&quot;)
    do
      if ! validate_file &quot;$changed_file&quot;; then
        echo &quot;Aborting commit&quot;
        exit 1
      fi
    done
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;参考&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://git-scm.com/book/en&quot;&gt;https://git-scm.com/book/en&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://floatingoctothorpe.uk/2017/empty-trees-in-git.html&quot;&gt;https://floatingoctothorpe.uk/2017/empty-trees-in-git.html&lt;/a&gt;&lt;/p&gt;
</content:encoded></item><item><title>深入理解数据库事务</title><link>https://smj.im/blag/posts/understanding-mysql-transaction/</link><guid isPermaLink="true">https://smj.im/blag/posts/understanding-mysql-transaction/</guid><pubDate>Sun, 20 Jun 2021 05:03:39 GMT</pubDate><content:encoded>&lt;h2&gt;定义&lt;/h2&gt;
&lt;p&gt;事务(Transaction)在计算机术语中是数据库管理系统执行过程中的一个由一个有限的数据库操作序列构成的逻辑单位。 在数据库中以一致模式完成的任何逻辑计算都称为事务。&lt;/p&gt;
&lt;h2&gt;性质&lt;/h2&gt;
&lt;p&gt;数据库事务通常包含了一个序列的对数据库的读/写操作。包含有以下两个目的：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;提供可靠的工作单元，可以从故障中正确恢复并保持数据库一致，即使在系统故障的情况下（执行停止（完全或部分）并且对数据库的许多操作仍未完成且状态不明时）。&lt;/li&gt;
&lt;li&gt;提供并发访问数据库的程序之间的隔离,以防止彼此的操作互相干扰。如果没有提供这种隔离，程序的结果可能是错误的。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;当事务被提交给了数据库管理系统（DBMS），则 DBMS 需要确保该事务中的所有操作都成功完成且其结果被永久保存在数据库中，如果事务中有的操作没有成功完成，则事务中的所有操作都需要回滚，回到事务执行前的状态；同时，该事务对数据库或者其他事务的执行无影响，所有的事务都好像在独立的运行。&lt;/p&gt;
&lt;h2&gt;ACID 特性&lt;/h2&gt;
&lt;p&gt;根据定义，数据库事务必须是&lt;strong&gt;原子&lt;/strong&gt;的（它必须是完整的或没有任何影响）、&lt;strong&gt;一致&lt;/strong&gt;的（它必须符合数据库中现有的约束）、&lt;strong&gt;隔离&lt;/strong&gt;的（它不能影响其他事务）和&lt;strong&gt;持久&lt;/strong&gt;的（它必须写入持久存储）。数据库从业者经常使用首字母缩写词 &lt;strong&gt;ACID&lt;/strong&gt; 来指代数据库事务的这些属性。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;原子性（Atomicity）&lt;/strong&gt;：事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;一致性（Consistency）&lt;/strong&gt;：事务应确保数据库的状态从一个一致状态转变为另一个一致状态。&lt;em&gt;一致状态&lt;/em&gt;的含义是数据库中的数据应满足完整性约束，即系统获得有效的新状态或保持在先前状态。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;隔离性（Isolation）&lt;/strong&gt;：处理过程中事务与其他事务分开，一个事务的执行不应影响其他事务的执行。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;持久性（Durability）&lt;/strong&gt;：已被提交的事务对数据库的修改应该永久保存在数据库中，即使在系统出现故障后系统仍保持有效状态。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;示例&lt;/h2&gt;
&lt;p&gt;张三要在商店购买 100 元的东西，当中至少包括两个操作：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;张三账户减少 100 元&lt;/li&gt;
&lt;li&gt;商店账户增加 100 元&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;原子性：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;数据库管理系统就要确保以上两个操作（整个“事务”）都能完成，或一起取消；否则就会出现 100 元平白消失或出现的情况。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一致性：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;交易完成，张三账户减少 100 元，商店账户增加 100 元&lt;/p&gt;
&lt;p&gt;交易失败，张三账户和商店账户不变&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;隔离性：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果张三在支付的同时，李四也在支付（是 50 元），那么即使李四取消支付，只要张三支付成功，商店账户也会增加 100 元，即不会影响张三的支付。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;持久性：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;交易完成，二者账户变化生效（写入数据库）&lt;/p&gt;
&lt;h2&gt;参考&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;http://www.hollischuang.com/archives/898&quot;&gt;http://www.hollischuang.com/archives/898&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1&quot;&gt;https://zh.wikipedia.org/wiki/数据库事务&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Database_transaction&quot;&gt;https://en.wikipedia.org/wiki/Database_transaction&lt;/a&gt;&lt;/p&gt;
</content:encoded></item><item><title>CRLF和LF之间的区别与联系</title><link>https://smj.im/blag/posts/diffrence-between-crlf-and-lf/</link><guid isPermaLink="true">https://smj.im/blag/posts/diffrence-between-crlf-and-lf/</guid><pubDate>Mon, 14 Jun 2021 10:52:39 GMT</pubDate><content:encoded>&lt;h2&gt;CRLF 与 LF：换行到底是什么？&lt;/h2&gt;
&lt;p&gt;要真正理解 CRLF 与 LF 换行的问题，我们需要复习一些排版历史。&lt;/p&gt;
&lt;p&gt;人们使用字母、数字和符号来相互交流。但是计算机只能理解和处理数字。由于计算机上的文件由人类可读的字符串组成，因此我们需要一个允许我们在这两种格式之间来回转换的系统。 ASCII 标准就是这样的系统——它将 A 和 z 等字符映射到数字，弥合了人类语言和计算机语言之间的鸿沟。&lt;/p&gt;
&lt;p&gt;有趣的是，ASCII 标准不仅仅适用于字母和数字等可见字符。某个子集是控制字符，也称为非打印字符。它们不用于渲染可见字符；相反，它们用于执行独特的操作，例如删除前一个字符或插入换行符。&lt;/p&gt;
&lt;p&gt;LF 和 CR 就是两个这样的控制字符，它们都与文件中的行尾有关。它们的历史可以追溯到打字机时代，因此我将简要介绍其工作原理，以便了解为什么我们有两个不同的控制字符而不是一个。然后，我们将看看这如何影响开发人员的体验。&lt;/p&gt;
&lt;h3&gt;LF：换行&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;LF&lt;/strong&gt;（Line Feed）代表“换行”，但你可能更熟悉术语换行符（转义序列 \n）。简单地说，这个字符代表一行文本的结束。在 Linux 和 Mac 上，这相当于新文本行的开始。这种区别很重要，因为 Windows 不遵循此约定。我们了解回车之后再讨论为什么不同。&lt;/p&gt;
&lt;h3&gt;CR：回车&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;CR&lt;/strong&gt;（Carriage Return）代表回车（转义序列\r），将光标移动到当前行的开头。终端上的下载进度条就是通过 CR 实现的，通过使用回车符，你的终端可以通过将光标返回到当前行的开头并覆盖任何先前呈现的文本来将文本动画化。&lt;/p&gt;
&lt;h4&gt;打字机和回车（CR）&lt;/h4&gt;
&lt;p&gt;将一张纸固定在称为托架的机械卷上，为设备送入一张纸。每次击键时，打字机都会使用墨水在您的纸张上打印字母，将笔架向左移动以确保键入的下一个字母会出现在前一个字母的右侧。&lt;/p&gt;
&lt;p&gt;当然，一旦当前行的空间用完，打字员就需要向下移动到纸张上的下一行。这是通过旋转滑架将纸张相对于打字机的“笔”向上移动一定距离来完成的。但是还需要重置托架（carriage），以便键入的下一个字符将与纸张的左侧边距对齐。换句话说，打字员需要某种方式将托架返回到其起始位置。而这正是回车的工作：一个金属杆连接到托架的左侧，当推动时，将托架返回到其起始位置。&lt;/p&gt;
&lt;h4&gt;电传打字机和回车换行（CRLF）&lt;/h4&gt;
&lt;p&gt;进入 20 世纪初，出现了电传打字机。基本上，它的工作方式与手动打字机相同，除了不是打印到物理纸上，而是通过传输器通过物理电线或无线电波将消息发送给接收方。&lt;/p&gt;
&lt;p&gt;虽然打印方式不同，但是同样需要使用换行符 (LF) 和回车符 (CR)，而且这些设备需要同时使用换行符 (LF) 和回车符 (CR) 以允许打字员从下一行文本的开头输入。毕竟手动打字机就是这样工作的，只是它没有任何“字符”的概念，因为它是一种机械操作的设备。&lt;/p&gt;
&lt;p&gt;我们可以将 LF 和 CR 视为代表水平或垂直方向上的独立运动，而不是同时代表两者，这样更容易将其形象化。为了实现这个功能，电传打字机在一些最早的操作系统中设定了 CRLF 行尾的标准，比如流行的 MS-DOS。将 CR 代表“回车”——CR 控制字符将打印头（“回车”）返回到第 0 列，而无需推进纸张。 LF 代表“换行”——LF 控制字符在不移动打印头的情况下将纸张前进一行。因此，如果您想将打印头返回到第 0 列（准备打印下一行）并推进纸张（以便在新纸上打印），则需要 CR 和 LF。&lt;/p&gt;
&lt;p&gt;MS-DOS 使用 CRLF 的两个字符组合来表示文件中的行尾，现代 Windows 计算机一直使用 CRLF 作为行尾。同时，从一开始，Unix 就使用 LF 来表示行尾，为了一致性和简单性而放弃了 CRLF。 Apple 最初仅在 Mac Classic 上使用 CR，但最终在 OS X 上改用了 LF，与 Unix 一致。&lt;/p&gt;
&lt;p&gt;虽然这似乎是操作系统之间的差异，但 CRLF 与 LF 的这个问题已经引起人们很长时间的头痛。其实按照今天的标准 CRLF 是多余的——同时使用回车和换行是假设你受到打字机的物理限制，你必须明确地向上移动你的纸，然后重置移动到左边距。但是对于电子文件，将换行符定义为隐式完成换行和回车的工作就足够了。换句话说，只要操作系统定义换行符表示下一行从开头开始而不是从某个任意的列偏移处开始，那么除了换行之外，我们不需要显式回车——一个符号可以完成两者的工作。&lt;/p&gt;
&lt;p&gt;现在我们知道 CRLF 和 CR 是如何起源的，接下来我们来学习以下怎么处理相关的问题。&lt;/p&gt;
&lt;h2&gt;检查和转换行尾（在 Bash 中）&lt;/h2&gt;
&lt;p&gt;在 bash 中，你可以使用带有 A 标志的 cat 查看特定文件的行尾：&lt;/p&gt;
&lt;p&gt;如果文件使用 CRLF，您将在每行末尾看到字符串 &lt;code&gt;^M$&lt;/code&gt;，其中 &lt;code&gt;^M&lt;/code&gt; 表示回车，&lt;code&gt;$&lt;/code&gt; 表示换行。下面是一个示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    line one^M$
    line two^M$
    line three^M$
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果文件使用 LF，那么您只会看到美元符号：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    line one$
    line two$
    line three$
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ps: 你可以使用&lt;a href=&quot;https://linux.die.net/man/1/dos2unix&quot;&gt;dos2unix&lt;/a&gt;命令行程序将文件从 CRLF 转换为 LF。&lt;/p&gt;
&lt;h2&gt;Git 中的行尾&lt;/h2&gt;
&lt;p&gt;诚然，这需要很多背景知识！但这是值得的，因为我们终于准备好讨论与 git 相关的行尾（以及如何在任何给定的代码库中解决 CRLF 与 LF 的问题）。&lt;/p&gt;
&lt;p&gt;我们从前面可以知道 CRLF 和 LF 是不同的字符表示，因此缺少通用行结尾为 git 等版本控制软件带来了麻烦，这类软件依赖于非常精确的字符比较来确定文件自上次签入以来是否发生了变化。如果开发人员使用 Windows 并且另一个使用 Mac 或 Linux，他们每个人都保存和提交相同的文件，他们可能会在他们的 git diff 中看到行结束更改——从 CRLF 到 LF 的转换，反之亦然。由于单字符更改，这会导致不必要的麻烦，非常烦人。&lt;/p&gt;
&lt;h3&gt;使用 &lt;code&gt;core.autocrlf&lt;/code&gt; 在 Git 中配置行尾&lt;/h3&gt;
&lt;p&gt;可以使用&lt;code&gt;core.autocrlf&lt;/code&gt;配置告诉 git 如何处理系统上的行尾。可以通过以下命令完成：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    git config --global core.autocrlf [true|false|input]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意，false 值会关闭行尾转换，这通常是不可取的，除非是团队中的每个人都使用相同的操作系统。当然，我觉得这种情况很少发生，所以慎用（除非你使用 .gitattributes 配置，在这种情况下，它会优先于你的 git 配置——稍后会详细介绍）。&lt;/p&gt;
&lt;p&gt;所以，一般来说我们只有两个选择：&lt;code&gt;autocrlf true&lt;/code&gt; 和 &lt;code&gt;autocrlf input&lt;/code&gt;。这两者有什么区别？&lt;/p&gt;
&lt;h4&gt;&lt;code&gt;autocrlf true&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;当 autocrlf 为 true 时（git 默认行为），文件将使用 git 在本地检出为 CRLF，但是每当你提交文件时，CRLF 的所有实例都将替换为 LF。基本上，此设置可确保你的代码库在所有文件的最终版本中始终使用 LF，但在获取时在本地使用 CRLF。这是 Windows 开发人员的推荐设置，因为 CRLF 是 Windows 的本机行结尾。&lt;/p&gt;
&lt;p&gt;如果使用此选项，则每次在 Windows 上暂存文件以进行提交时可能会看到下面警告：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    warning: CRLF will be replaced by LF in &amp;lt;file-name&amp;gt;.
    The file will have its original line endings in your working directory.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这并不是说出现问题， Git 只是警告你，根据此设置的预期行为，你的 CRLF 行结尾将在提交时规范化为 LF。&lt;/p&gt;
&lt;h4&gt;&lt;code&gt;autocrlf input&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;使用 &lt;code&gt;autocrlf input&lt;/code&gt;，文件在提交时转换为 LF，但在获取时不会转换为任何内容。因此名称为“输入”——你得到是你最初输入的内容。如果一个文件最初被 Windows 开发人员意外提交为 CRLF，你会在本地看到它是 CRLF（如果你修改它，你会强制它变成 LF）。如果文件最初是作为 LF 添加的，您会看到它是 LF。这通常是一件好事，因为这意味着你将始终在代码库中获得 LF 行结尾（假设你从一开始就使用它）。&lt;/p&gt;
&lt;p&gt;input 和 true 之间的唯一区别是输入不会在本地获取时处理行尾。这是 Mac/Linux 开发人员的推荐设置，因为这些操作系统默认使用 LF。&lt;/p&gt;
&lt;h2&gt;使用 .gitattributes 在 Git 中规范行尾&lt;/h2&gt;
&lt;p&gt;在你的 repo 的根目录创建一个 .gitattributes 文件来一劳永逸地行尾不一致的问题。 Git 会读取此文件并在您本地获取或提交文件时应用其规则，确保无论每个开发人员如何在本地配置 git 或他们使用什么操作系统，都强制执行行尾约定。&lt;/p&gt;
&lt;h3&gt;一个简单的 .gitattributes 配置&lt;/h3&gt;
&lt;p&gt;这是一个 .gitattributes 文件，应该涵盖大多数用例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    # We&apos;ll let Git&apos;s auto-detection algorithm infer if a file is text. If it is,
    # enforce LF line endings regardless of OS or git configurations.
    * text=auto eol=lf

    # Isolate binary files in case the auto-detection algorithm fails and
    # marks them as text files (which could brick them).
    *.{png,jpg,jpeg,gif,webp,woff,woff2} binary
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;提交该文件并将其推送到远程服务器。&lt;/p&gt;
&lt;p&gt;git 使用一种简单的算法来检测你的 repo 中的特定文件是文本文件还是二进制文件（例如，可执行文件、图像或字体文件）。默认情况下，此算法用于比较已更改的文件，但它也可以用于强制行尾约定。&lt;/p&gt;
&lt;p&gt;这就是上面配置中 &lt;code&gt;text=auto&lt;/code&gt; 的作用——它告诉 git 应用其自动检测算法来确定文件是否是文本文件。然后， &lt;code&gt;eol=lf&lt;/code&gt; 告诉 git 在本地获取和提交时强制执行文本文件的 LF 行结尾。这适用于 Windows 和 Linux，因为现在大多数跨平台文本编辑器都支持 LF。&lt;/p&gt;
&lt;p&gt;Git 的自动检测算法相当准确，但如果它无法正确区分文本文件和二进制文件（如图像或字体文件），我们也可以将文件的子集显式标记为二进制文件以避免作为文本文件处理他们。这可以用下面的代码实现：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    *.{png,jpg,jpeg,gif,webp,woff,woff2} binary
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;现在，提交此文件后，最后一步是重新规范化所有在添加 &lt;code&gt;.gitattributes&lt;/code&gt; 之前已签入 git 的文件的所有行尾。你可以使用以下命令执行此操作：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    git add --renormalize .
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这会根据 &lt;code&gt;.gitattributes&lt;/code&gt; 配置中定义的规则重新格式化所有文件。如果先前提交的文件在 git 的索引中使用 CRLF 并且由于此重新规范化而转换为 LF，则它们的行尾将在索引中更新，并且这些文件将暂存以进行提交。唯一要做的就是提交这些更改并将它们推送到远程存储库。之后引入的新文件，其行尾都将作为 LF 签入（和签出）。&lt;/p&gt;
&lt;h4&gt;Git 行尾：工作树与索引&lt;/h4&gt;
&lt;p&gt;提交这些重新规范化的文件时，您可能会看到以下消息：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    warning: CRLF will be replaced by LF in &amp;lt;file-name&amp;gt;.
    The file will have its original line endings in your working directory.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这是预期的行为——CRLF 将成为 Git 索引中的 LF，这意味着当你将这些文件推送到你的存储库时，它们将在你的远程代码库中具有 LF 行结尾。任何后来提取或获取该代码的人都会在本地看到 LF 行结尾。&lt;/p&gt;
&lt;p&gt;但是 git 实际上并没有更改文件的本地文件（即其工作树中的那些）的行尾。因此，警告消息的最后一点表示刚刚重新规范化的文件仍会继续在本地使用 CRLF。&lt;/p&gt;
&lt;h3&gt;在 Git 中验证任何文件的行尾&lt;/h3&gt;
&lt;p&gt;如果想在所有这些步骤之后仔细检查 Git 索引中的文件是否使用正确的行结尾，可以运行以下命令：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    git ls-files --eol
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这将显示 git 正在跟踪的所有文件的行尾信息，格式如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    i/lf    w/crlf  attr/text=auto eol=lf   file.txt
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从左到右分别是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;i：索引中的行尾（被推送到你的仓库的行）。应该是 LF。&lt;/li&gt;
&lt;li&gt;w：工作树中的行尾（可能是 CRLF，但如果索引是 LF 也可以）。&lt;/li&gt;
&lt;li&gt;attr：适用于此文件的 &lt;code&gt;.gitattributes&lt;/code&gt; 规则。&lt;/li&gt;
&lt;li&gt;文件名。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;或者，你可以在将代码推送到远程后，通过在 Windows 机器上重新克隆您的存储库来仔细检查 git 是否正确规范了您的行尾。你应该看到文件的索引和工作树副本都使用 LF 而不是 CRLF（假设 LF 是您选择规范化行尾的方式）。&lt;/p&gt;
&lt;h2&gt;&lt;code&gt;.editorconfig&lt;/code&gt; 文件&lt;/h2&gt;
&lt;p&gt;从技术上讲，一个 &lt;code&gt;.gitattributes&lt;/code&gt; 文件是你执行代码库远程副本上显示的行尾所需的全部内容。但是，正如我们在上面看到的，你可能仍然会在本地看到你创建的文件的 CRLF 行结尾，因为 .gitattributes 不会告诉 git 更改文件的工作副本。&lt;/p&gt;
&lt;p&gt;当然，这并不意味着 git 的规范化过程不起作用。但是，如果你还使用 ESLint 和 Prettier 对代码进行 linting，这可能会很烦人，在这种情况下，它们会不断抛出错误并告诉您删除那些额外的 CR：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pichost.netlify.app/blog/656042bf2a70c.webp&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;p&gt;所以，你可以使用 &lt;code&gt;.editorconfig&lt;/code&gt; 文件更进一步；这是一个与编辑器无关的项目，旨在创建用于自定义任何给定文本编辑器行为的标准化格式。许多文本编辑器（包括 &lt;code&gt;VS Code&lt;/code&gt;，&lt;code&gt;IDEA&lt;/code&gt;，&lt;code&gt;GitHub&lt;/code&gt;）支持并自动读取此文件（如果存在）。你可以将这样的内容放在工作区的根目录中，你可以在&lt;a href=&quot;https://editorconfig.org&quot;&gt;这里&lt;/a&gt;深入了解：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    root = true

    [*]
    end_of_line = lf

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;除了一堆其他设置之外，你还可以指定应用于通过此文本编辑器创建的任何新文件的行尾。这样，如果使用 VS Code 在 Windows 上创建一个新文件，你将始终在工作树中看到行结尾为 LF。&lt;/p&gt;
&lt;h2&gt;参考&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://stackoverflow.com/a/56858538/5323344&quot;&gt;https://stackoverflow.com/a/56858538/5323344&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.aleksandrhovhannisyan.com/blog/crlf-vs-lf-normalizing-line-endings-in-git/&quot;&gt;https://www.aleksandrhovhannisyan.com/blog/crlf-vs-lf-normalizing-line-endings-in-git/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://editorconfig.org/&quot;&gt;https://editorconfig.org/&lt;/a&gt;&lt;/p&gt;
</content:encoded></item><item><title>DNS的更新是如何工作的？</title><link>https://smj.im/blag/posts/how-update-dns-works/</link><guid isPermaLink="true">https://smj.im/blag/posts/how-update-dns-works/</guid><description>最近看到大神的一篇关于DNS的文章，感觉很不错，所以自己翻译了一下。</description><pubDate>Wed, 09 Jun 2021 02:06:04 GMT</pubDate><content:encoded>&lt;blockquote&gt;
&lt;p&gt;最近看到大神的一篇关于&lt;a href=&quot;https://jvns.ca/blog/how-updating-dns-works&quot;&gt;DNS 的文章&lt;/a&gt;，感觉很不错，所以自己翻译了一下。
如有错误，欢迎指正。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我已经看到很多人对更新站点的 DNS 记录以更改 IP 地址感到困惑。为什么这么慢？是否真的需要等待 2 天才能更新所有内容？为什么有些人看到新 IP，有些人看到旧 IP？发生了什么？&lt;/p&gt;
&lt;p&gt;这里记录一下更新 DNS 背后所发生了些什么。&lt;/p&gt;
&lt;h2&gt;DNS 的分类：递归 vs 权威 DNS 服务器&lt;/h2&gt;
&lt;p&gt;首先，我们需要解释一些有关 DNS 的知识。DNS 服务器有两种：&lt;strong&gt;权威&lt;/strong&gt;服务器和&lt;strong&gt;递归&lt;/strong&gt;服务器。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;权威&lt;/strong&gt;DNS 服务器（也称为&lt;strong&gt;名称服务器&lt;/strong&gt;）具有一个负责其每个域名的 IP 地址数据库。例如，github.com 的权威 DNS 服务器是 ns-421.awsdns-52.com。你可以通过 dig 命令来获取 github.com 的 IP。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;dig @ns-421.awsdns-52.com github.com
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;递归&lt;/strong&gt;DNS 服务器本身对谁拥有什么 IP 地址一无所知。它们通过询问正确的权威 DNS 服务器来确定域名的 IP 地址，然后缓存该 IP 地址，以防再次被问到。8.8.8.8 是递归 DNS 服务器。&lt;/p&gt;
&lt;p&gt;当人们访问你的网站时，他们可能正在对递归 DNS 服务器进行 DNS 查询。那么，递归 DNS 服务器如何工作？让我们来看看！&lt;/p&gt;
&lt;h2&gt;递归 DNS 服务器如何查询 github.com？&lt;/h2&gt;
&lt;p&gt;我们来看一个递归 DNS 服务器（如 8.8.8.8）在你请求 github.com 的 IP 地址（A 记录）时的功能的示例。首先–如果已经缓存了某些内容，它将为您提供缓存的内容。但是，如果所有缓存均已过期怎么办？这是发生了什么：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;步骤 1&lt;/strong&gt;：在源代码中硬编码根 DNS 服务器的 IP 地址。您可以在&lt;a href=&quot;https://github.com/NLnetLabs/unbound/blob/6e0756e819779d9cc2a14741b501cadffe446c93/iterator/iter_hints.c#L131&quot;&gt;unbound 的源代码中&lt;/a&gt;看到这一点。假设&lt;code&gt;198.41.0.4&lt;/code&gt;从开始就选择。这是这些硬编码 IP 地址的&lt;a href=&quot;https://www.iana.org/domains/root/files&quot;&gt;正式来源&lt;/a&gt;，也称为“根目录提示文件”。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;步骤 2&lt;/strong&gt;：向根域名服务器查询&lt;code&gt;github.com&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;我们可以大致再现发生的情况&lt;code&gt;dig&lt;/code&gt;。这给我们提供了一个新的权威名称服务器：&lt;code&gt;.com&lt;/code&gt;IP 的名称服务器&lt;code&gt;192.5.6.30&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ dig @198.41.0.4 github.com
...
com.            172800  IN  NS  a.gtld-servers.net.
...
a.gtld-servers.net.    172800  IN  A   192.5.6.30
...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;DNS 响应的详细信息比这要复杂一些–在这种情况下，其中有一个具有一些 NS 记录的授权部分，而另一个具有 A 记录的部分，因此您无需进行额外的查找即可获得这些名称服务器 IP 地址。&lt;/p&gt;
&lt;p&gt;（实际上，它已经有 99.99％的时间已经缓存了&lt;code&gt;.com&lt;/code&gt;名称服务器的地址，但是我们假装实际上是从头开始的）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;步骤 3&lt;/strong&gt;：向&lt;code&gt;.com&lt;/code&gt;域名服务器查询有关&lt;code&gt;github.com&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    $ dig @192.5.6.30 github.com
    ...
    github.com.        172800  IN  NS  ns-421.awsdns-52.com.
    ns-421.awsdns-52.com.    172800  IN  A   205.251.193.165
    ...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们有一个新的 IP 地址要询问！这是&lt;code&gt;github.com&lt;/code&gt;的名称服务器。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;步骤 4&lt;/strong&gt;：向&lt;code&gt;github.com&lt;/code&gt;域名服务器询问有关&lt;code&gt;github.com&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    $ dig @205.251.193.165 github.com

    github.com.        60  IN  A   140.82.112.4
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;OK！我们现在有一个&lt;code&gt;github.com&lt;/code&gt;的&lt;code&gt;A&lt;/code&gt;记录！现在，递归名称服务器具有&lt;code&gt;github.com&lt;/code&gt;的 IP 地址，可以将其返回给您。它通过仅硬编码几个&lt;strong&gt;IP 地址&lt;/strong&gt;即可完成所有这些操作：即根名称服务器的地址。&lt;/p&gt;
&lt;h2&gt;如何查看所有递归 DNS 服务器： &lt;code&gt;dig+trace&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;当我想查看解析一个域名时递归 DNS 服务器将执行的操作，我运行以下命令:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    $ dig @8.8.8.8 +trace github.com
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这显示了它请求的所有 DNS 记录，从根 DNS 服务器开始--我们刚刚完成的所有 4 个步骤。&lt;/p&gt;
&lt;h2&gt;如何更新 DNS 记录&lt;/h2&gt;
&lt;p&gt;既然我们了解了 DNS 工作原理，那么让我们更新一些 DNS 记录，看看会发生什么。&lt;/p&gt;
&lt;p&gt;更新 DNS 记录时，有两个主要选项：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;保持相同的名称服务器&lt;/li&gt;
&lt;li&gt;更改名称服务器&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;关于 TTL&lt;/h3&gt;
&lt;p&gt;这里我们先说明一下 TTL 这个概念，我们之前说过递归 DNS 服务器将缓存记录直到它们过期，而决定记录是否应过期的方式是查看其&lt;strong&gt;TTL(Time To Live)&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;下面的示例中，A 记录 github 的名称服务器为其 DNS 记录返回的 TTL 为&lt;code&gt;60&lt;/code&gt;，这意味着 60 秒：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    $ dig @205.251.193.165 github.com
    github.com.        60  IN  A   140.82.112.4
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这是一个非常短的 TTL，*从理论上讲，*如果每个人的 DNS 实施都遵循&lt;a href=&quot;https://tools.ietf.org/html/rfc1035&quot;&gt;DNS 标准，&lt;/a&gt;则意味着如果 Github 决定更改 IP 地址&lt;code&gt;github.com&lt;/code&gt;，则每个人都应在 60 秒内获得新的 IP 地址。让我们看看实际情况如何。&lt;/p&gt;
&lt;h3&gt;选项 1：在相同的名称服务器上更新 DNS 记录&lt;/h3&gt;
&lt;p&gt;首先，我更新了我的名称服务器（Cloudflare），使其具有新的 DNS 记录：映射&lt;code&gt;test.jvns.ca&lt;/code&gt;到的 A 记录 &lt;code&gt;1.2.3.4&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    $ dig @8.8.8.8 test.jvns.ca
    test.jvns.ca.        299 IN  A   1.2.3.4
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这会立即生效！根本不需要等待，因为&lt;code&gt;test.jvns.ca&lt;/code&gt;在可以缓存之前没有 DNS 记录。但是看起来新记录被缓存了大约 5 分钟（299 秒）。&lt;/p&gt;
&lt;p&gt;那么，如果我们尝试更改该 IP 怎么办？我将其更改为&lt;code&gt;5.6.7.8&lt;/code&gt;，然后运行了相同的 DNS 查询。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    $ dig @8.8.8.8 test.jvns.ca
    test.jvns.ca.        144 IN  A   1.2.3.4
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;嗯，好像 DNS 服务器的&lt;code&gt;1.2.3.4&lt;/code&gt;记录仍在缓存 144 秒。有趣的是，如果我&lt;code&gt;8.8.8.8&lt;/code&gt;多次查询实际上却得到不一致的结果–有时它会给我新的 IP，有时会给我旧的 IP，我想是因为 8.8.8.8 实际上将负载平衡到一堆不同的后端，每个后端都有自己的缓存。&lt;/p&gt;
&lt;p&gt;我等了 5 分钟后，所有&lt;code&gt;8.8.8.8&lt;/code&gt;缓存均已更新，并且始终返回新&lt;code&gt;5.6.7.8&lt;/code&gt;记录。不得不说，这相当的快！&lt;/p&gt;
&lt;h3&gt;你不能总是依靠 TTL&lt;/h3&gt;
&lt;p&gt;与大多数 Internet 协议一样，并非所有内容都遵循 DNS 规范。某些 ISP DNS 服务器将缓存记录的时间长于 TTL 指定的时间，例如 2 天而不是 5 分钟。人们总是可以在/etc/hosts 中对旧 IP 地址进行硬编码。&lt;/p&gt;
&lt;p&gt;在使用 5 分钟的 TTL 更新 DNS 记录时，我期望在实践中会发生的事情是，很大比例的客户端会迅速（例如在 15 分钟之内）移到新 IP，然后会有一些慢的客户端在接下来的几天内会慢慢更新。&lt;/p&gt;
&lt;h3&gt;选项 2：更新名称服务器&lt;/h3&gt;
&lt;p&gt;我们已经看到，当您在不更改名称服务器的情况下更新 IP 地址时，许多 DNS 服务器将很快获取新 IP。但是，如果您更改名称服务器会怎样？&lt;/p&gt;
&lt;p&gt;我不想更新我的博客的域名服务器，所以不是我用不同的域名然后用在&lt;a href=&quot;https://wizardzines.com/zines/http/&quot;&gt;HTTP 杂志&lt;/a&gt;作为示例：&lt;code&gt;examplecat.com&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;以前，我的名称服务器设置为 dns1.p01.nsone.net。我决定将它们切换到 Google 的名称服务器-&lt;code&gt;ns-cloud-b1.googledomains.com&lt;/code&gt;等等。&lt;/p&gt;
&lt;p&gt;进行更改后，我的域名注册商有点不愉快地弹出了消息-“对 examplecat.com 的更改已保存。它们将在接下来的 48 小时内生效。” 然后，我为该域设置了一个新的 A 记录，使其指向&lt;code&gt;1.2.3.4&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;OK，让我们看看是否有任何作用：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    $ dig @8.8.8.8 examplecat.com
    examplecat.com.        17  IN  A   104.248.50.87
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;没变化。如果我询问其他 DNS 服务器，它将返回新 IP 地址：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    $ dig @1.1.1.1 examplecat.com
    examplecat.com.        299 IN  A   1.2.3.4
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但是 8.8.8.8 仍然毫无变化。即使我在 5 分钟前刚刚更改它，1.1.1.1 能看到新 IP 的原因大概是以前没有人向 1.1.1.1 询问过 examplecat.com，因此它的缓存中没有任何内容。&lt;/p&gt;
&lt;h2&gt;名称服务器的 TTL 更长&lt;/h2&gt;
&lt;p&gt;我的注册服务商说“这将花费 48 小时”的原因是 NS 记录上的 TTL（这是递归名称服务器如何知道要询问哪个名称服务器）更长！&lt;/p&gt;
&lt;p&gt;新的域名服务器肯定会返回新的 IP 地址 &lt;code&gt;examplecat.com&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    $ dig @ns-cloud-b1.googledomains.com examplecat.com
    examplecat.com.        300 IN  A   1.2.3.4
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但是还记得当我们查询&lt;code&gt;github.com&lt;/code&gt;域名服务器时发生了什么吗？&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    $ dig @192.5.6.30 github.com
    ...
    github.com.        172800  IN  NS  ns-421.awsdns-52.com.
    ns-421.awsdns-52.com.    172800  IN  A   205.251.193.165
    ...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;172800 秒是 48 个小时！因此，与不更改名称服务器而仅更新 IP 地址相比，名称服务器更新通常需要更长的时间才能从缓存中到期并传播使用。&lt;/p&gt;
&lt;h2&gt;域名服务器如何更新？&lt;/h2&gt;
&lt;p&gt;当我更新的域名服务器时&lt;code&gt;examplecat.com&lt;/code&gt;，发生的事情是 &lt;code&gt;.com&lt;/code&gt;域名服务器获得了&lt;code&gt;NS&lt;/code&gt;新域名的新记录。像这样：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    dig ns @j.gtld-servers.net examplecat.com

    examplecat.com.        172800  IN  NS  ns-cloud-b1.googledomains.com
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但是，新的 NS 记录如何到达那里？发生的事情是，我通过在网站上更新&lt;strong&gt;域名&lt;/strong&gt;告诉&lt;strong&gt;域名注册商&lt;/strong&gt;我希望新的域名服务器是什么，然后域名注册商告诉&lt;code&gt;.com&lt;/code&gt;域名服务器进行更新。&lt;/p&gt;
&lt;p&gt;对于&lt;code&gt;.com&lt;/code&gt;，这些更新发生的速度非常快（在几分钟之内），但是我认为对于其他一些 TLD，TLD 域名服务器可能无法尽快应用更新。&lt;/p&gt;
&lt;h2&gt;程序的 DNS 解析器库可能还会缓存 DNS 记录&lt;/h2&gt;
&lt;p&gt;实际中可能不遵守 TTL 的另一个原因：许多程序需要解析 DNS 名称，并且某些程序还将无限期地将 DNS 记录缓存在内存中（直到程序重新启动）。&lt;/p&gt;
&lt;p&gt;例如，AWS 有一篇关于&lt;a href=&quot;https://docs.aws.amazon.com/sdk-for-java/v1/developer-guide/java-dg-jvm-ttl.html&quot;&gt;为 DNS 名称查找设置 JVM TTL&lt;/a&gt;的文章。我没有编写太多可以自己进行 DNS 查找的 JVM 代码，但是通过对 JVM 和 DNS 的一些仔细研究，似乎可以配置 JVM，以便它无限期地缓存每个 DNS 查找。（例如&lt;a href=&quot;https://github.com/elastic/elasticsearch/issues/16412&quot;&gt;此 elasticsearch 问题&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;&lt;em&gt;p.s. TTL 不能说明 DNS 工作原理的全部–即使像 8.8.8.8 这样的主要 DNS 服务器，某些递归 DNS 服务器也绝对不尊重 TTL。因此，即使您只是用短的 TTL 更新 A 记录，实际上还是很有可能在一两天内收到对旧 IP 的一些请求。&lt;/em&gt;&lt;/p&gt;
&lt;h2&gt;参考&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://jvns.ca/blog/how-updating-dns-works&quot;&gt;https://jvns.ca/blog/how-updating-dns-works&lt;/a&gt;&lt;/p&gt;
</content:encoded></item><item><title>浅析Linux的cron命令</title><link>https://smj.im/blag/posts/linux-cron-tutorial/</link><guid isPermaLink="true">https://smj.im/blag/posts/linux-cron-tutorial/</guid><pubDate>Thu, 03 Dec 2020 03:54:58 GMT</pubDate><content:encoded>&lt;p&gt;Cron 是 Linux 一个很有用的工具，也是开发人员最喜欢的工具，因为它可以让你使用通用脚本和特定于任务的脚本在特定的时间段、日期和间隔自动运行命令。有了该描述，你可以想象系统管理员如何使用它来自动执行备份任务、目录清除、通知等。&lt;/p&gt;
&lt;p&gt;Cron 作业在后台运行，并不断检查&lt;code&gt;/etc/crontab&lt;/code&gt;文件，&lt;code&gt;/etc/cron.*/&lt;/code&gt;和&lt;code&gt;/var/spool/cron/&lt;/code&gt;目录。我们最好不要直接编辑 cron 文件，因为每个用户都有唯一的 crontab。&lt;/p&gt;
&lt;p&gt;那你应该如何创建和编辑 cron 作业？我们可以使用 crontab 命令。crontab 是用于创建，编辑，安装，卸载和列出 cron 作业的方法。&lt;/p&gt;
&lt;p&gt;创建和编辑 cron 作业的命令是相同而且很简单。而且更酷的是，你无需在创建新文件或编辑现有文件后重新启动 cron。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ crontab -e
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;&lt;strong&gt;Cron 语法&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;就像使用任何语言一样，当你了解&lt;strong&gt;cron&lt;/strong&gt;的语法时，使用&lt;strong&gt;cron&lt;/strong&gt;会容易得多，它的语法有两种格式：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;A B C D E USERNAME /path/to/command arg1 arg2
OR
A B C D E USERNAME /root/backup.sh
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以上 cron 语法的说明：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;A：分钟&lt;/strong&gt;范围：&lt;strong&gt;0 – 59&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;B：时间&lt;/strong&gt;范围：&lt;strong&gt;0 – 23&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;C：天数&lt;/strong&gt;范围：&lt;strong&gt;1 – 31&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;D：月&lt;/strong&gt;范围：&lt;strong&gt;1 – 12&lt;/strong&gt; or &lt;strong&gt;JAN-DEC&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;E：星期几&lt;/strong&gt;：&lt;strong&gt;0 – 6&lt;/strong&gt; or &lt;strong&gt;SUN-SAT，Sunday=0 or 7&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;USERNAME：&lt;/strong&gt; 用户名&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;/path/to/command&lt;/strong&gt; – 你要计划的脚本或命令的名称&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;形象一点表示就是：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;┌───────────── minute (0 - 59)
│ ┌───────────── hour (0 - 23)
│ │ ┌───────────── day of the month (1 - 31)
│ │ │ ┌───────────── month (1 - 12 or JAN-DEC)
│ │ │ │ ┌───────────── day of the week (0 - 6 or SUN-SAT, Sunday=0 or 7)
│ │ │ │ │
│ │ │ │ │
│ │ │ │ │
* * * * *
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;此外，Cron 使用 3 个运算符，可以在字段中指定多个值：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;星号&lt;code&gt;(*)&lt;/code&gt;&lt;/strong&gt;：指定字段的所有可能值，&lt;code&gt;* * * * *&lt;/code&gt; 在每天的每分钟运行。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;逗号&lt;code&gt;(,)&lt;/code&gt;&lt;/strong&gt;：指定值列表，&lt;code&gt;2,10 4,5 * * *&lt;/code&gt;在每天第 4 和第 5 小时的第 2 和第 10 分钟运行。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;破折号&lt;code&gt;(-)&lt;/code&gt;&lt;/strong&gt;：指定值范围，&lt;code&gt;0 4-6 * * *&lt;/code&gt; 在第 4、5、6 小时的第 0 分钟运行。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;分隔符&lt;code&gt;(/)&lt;/code&gt;&lt;/strong&gt;：指定步长值，&lt;code&gt;20/15 * * * *&lt;/code&gt; 从第 20 分钟到第 59 分钟每隔 15 分钟运行（第 20、35 和 50 分钟）。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Cron 的语法和运算符大概就这么多，下面展示一些 cron 示例。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;Cron 工作示例&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;运行 cron 命令的第一步是使用以下命令安装 crontab：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#crontab -e
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在每天&lt;strong&gt;凌晨 3 点&lt;/strong&gt;运行&lt;code&gt;/root/backup.sh&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;0 3 * * * /root/backup.sh
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在每个月的第二天的&lt;strong&gt;下午 4:30&lt;/strong&gt;运行&lt;code&gt;script.sh&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;30 16 2 * * /path/to/script.sh
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在每周工作日的晚上&lt;strong&gt;10 点&lt;/strong&gt;运行&lt;code&gt;/scripts/phpscript.php&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;0 22 * * 1-5 /scripts/phpscript.php
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在每天的午夜，凌晨 2 点和凌晨 4 点后的&lt;strong&gt;23 分钟&lt;/strong&gt;，运行&lt;code&gt;perlscript.pl&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;23 0-23 / 2 * * * /path/to/perlscript.pl
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;每个星期日的 04:05 运行 Linux 命令：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;5 4 * * sun /path/to/linuxcommand
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;&lt;strong&gt;Cron 选项&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;列出 cron 作业。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#crontab -l
OR
#crontab -u username -l
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;删除所有 crontab 作业。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#crontab -r
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;删除特定用户的 Cron 作业。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#crontab -r -u username
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;&lt;strong&gt;Crontab 中的字符串&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;字符串是开发人员最喜欢的东西，因为它们通过消除重复的书写来帮助节省时间。Cron 具有特定的字符串，可用于更快地创建命令：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;@hourly&lt;/code&gt;：每小时运行一次，即&quot;&lt;strong&gt;0 * * * *&lt;/strong&gt;&quot;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@midnight&lt;/code&gt;：每天运行一次，即&quot;&lt;strong&gt;0 0 * * *&lt;/strong&gt;&quot;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@daily&lt;/code&gt;：与午夜相同&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@weekly&lt;/code&gt;：每周运行一次，即&quot;&lt;strong&gt;0 0 * * 0&lt;/strong&gt;&quot;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@monthly&lt;/code&gt;：每月运行一次，即&quot;&lt;strong&gt;0 0 1 * *&quot;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@annually&lt;/code&gt;：每年运行一次，即&quot;&lt;strong&gt;0 0 1 1 *&lt;/strong&gt;&quot;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@yearly&lt;/code&gt;：与**@annually**相同&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@reboot&lt;/code&gt;：每次启动时运行一次&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;例如，这是每天备份系统的方法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@daily /path/to/backup/script.sh
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;至此，你已经拥有使用&lt;strong&gt;Cron&lt;/strong&gt;创建和管理系统任务所需的全部内容。现在，你可以开始使用计划的命令来设置和维护多个环境。&lt;/p&gt;
&lt;p&gt;当你对 Crontab 的工作方式了解得足够多时，可以使用这些漂亮的&lt;a href=&quot;https://www.tecmint.com/online-cron-job-generator-and-tester-for-linux/&quot;&gt;Crontab 生成器实用程序&lt;/a&gt;免费生成 crontab 行。&lt;/p&gt;
&lt;p&gt;另外，你可以在&lt;a href=&quot;https://help.ubuntu.com/community/CronHowto&quot;&gt;此处&lt;/a&gt;阅读 Ubuntu 的有关如何使用 Cron 的文章。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;参考&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.tecmint.com/create-and-manage-cron-jobs-on-linux/&quot;&gt;https://www.tecmint.com/create-and-manage-cron-jobs-on-linux/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.github.com/en/free-pro-team@latest/actions/reference/events-that-trigger-workflows&quot;&gt;https://docs.github.com/en/free-pro-team@latest/actions/reference/events-that-trigger-workflows&lt;/a&gt;&lt;/p&gt;
</content:encoded></item><item><title>如何快速查看github代码库中早期commits</title><link>https://smj.im/blag/posts/quickly-locate-early-commits-in-github/</link><guid isPermaLink="true">https://smj.im/blag/posts/quickly-locate-early-commits-in-github/</guid><pubDate>Thu, 03 Dec 2020 02:32:58 GMT</pubDate><content:encoded>&lt;p&gt;如果你想要学习一个开源库，最好的方法就是从头开始看源码，所以你可能想要从第一次 commit 开始看。有的人可能觉得很简单啊，进入 commit 页面直接翻到最后一页就好了啊。的确，如果是你看的是一个小的项目，提交次数不会太多，你可能翻几页就到最后了，可是，如果是像 Linux 这种项目，将近 100k 次提交，手动翻页翻到明年了。。。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pichost.netlify.app/blog/6560441bb9c20.webp&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pichost.netlify.app/blog/6560443b09e1c.webp&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;p&gt;这时候就需要一个简单的方法能够定位到第一次 commit。&lt;/p&gt;
&lt;p&gt;所以第一个想法就是在 URL 上操作，仔细观察对比之后可以发现，GitHub 的翻页是根据 commit 的 SHA 值来定位的，&lt;/p&gt;
&lt;p&gt;第二页的 url 是&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/torvalds/linux/commits/master?after=127c501a03d5db8b833e953728d3bcf53c8832a9+34&amp;amp;branch=master&quot;&gt;https://github.com/torvalds/linux/commits/master?after=127c501a03d5db8b833e953728d3bcf53c8832a9+34&amp;amp;branch=master&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;仔细观察其中的&lt;code&gt;127c501a03d5db8b833e953728d3bcf53c8832a9&lt;/code&gt;是最新一次 commit 的 SHA 值，后面还有一个&lt;code&gt;+34&lt;/code&gt;就是定位到第 36 次(因为是 after1+34，所以要是 36)的 commit。所以要定位到 Linux 的第一次 commit 就可以把+34 改为+967826(967828-2)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pichost.netlify.app/blog/6560444e8d792.webp&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;p&gt;到这里就成功定位到第一次 commit 了，当然，以此类推，你可以定位到任何一个 commit。&lt;/p&gt;
</content:encoded></item><item><title>黑科技：使用GitHub搭建自己的短链接服务</title><link>https://smj.im/blag/posts/deploy-a-url-shortener-using-github/</link><guid isPermaLink="true">https://smj.im/blag/posts/deploy-a-url-shortener-using-github/</guid><description>使用两个GitHub仓库和一个域名就能拥有免费的短链接服务。</description><pubDate>Tue, 01 Dec 2020 08:25:45 GMT</pubDate><content:encoded>&lt;p&gt;前两天偶然在 GitHub 发现一个挺有意思的项目，可以不依赖自己的服务器、数据库来构建一个短链接服务。自己尝试了一下，还挺简单的。这里记录一下自己的构建流程，感兴趣的小伙伴可以自己尝试一下。&lt;/p&gt;
&lt;h2&gt;Prerequisites&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;新建两个 GitHub 仓库，一个用来做服务器存储源码、提供服务(url_shortener)，一个用来做数据库存储链接(url_shortener_db)&lt;/li&gt;
&lt;li&gt;注册一个域名（可选），如果没有的话，可以直接使用 GitHub pages 的域名(&lt;code&gt;username.github.io&lt;/code&gt;)。不过我是用了自己注册的域名：blog.johan.zone&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;获取及配置源码&lt;/h2&gt;
&lt;p&gt;首先，你需要获取这个服务的源代码，你可以直接 fork 这个&lt;a href=&quot;https://github.com/nelsontky/gh-pages-url-shortener&quot;&gt;源码仓库&lt;/a&gt;，当然也欢迎 fork 我的&lt;a href=&quot;https://github.com/baddate/url_shortener&quot;&gt;代码仓库&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;然后，克隆自己的仓库到本地(当然，你也可以直接在 GitHub 网页上操作)，修改&lt;code&gt;404.html&lt;/code&gt;文件的&lt;code&gt;GITHUB_ISSUES_LINK&lt;/code&gt;字段，指向自己的&lt;code&gt;url_shortener_db&lt;/code&gt;仓库，这个仓库的&lt;code&gt;issues&lt;/code&gt;就是作为存储你的链接的数据库：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var GITHUB_ISSUES_LINK =
&quot;https://api.github.com/repos/username/repo-name/issues/&quot;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;注意把上面的&lt;code&gt;username&lt;/code&gt; &lt;code&gt;repo-name&lt;/code&gt;替换为自己的用户名及仓库名。还有，&lt;strong&gt;最后的&lt;code&gt;/&lt;/code&gt;不要漏掉&lt;/strong&gt;，这是获取链接的关键&lt;/em&gt;&lt;/p&gt;
&lt;h2&gt;配置 GitHub Pages&lt;/h2&gt;
&lt;p&gt;接下来就是配置 Github Pages 了，这部分也很简单。&lt;/p&gt;
&lt;p&gt;点击仓库的&lt;code&gt;Settings&lt;/code&gt;选项，找到其中的&lt;code&gt;GitHub Pages&lt;/code&gt;部分，然后配置&lt;code&gt;Source&lt;/code&gt;中的分支：
&lt;img src=&quot;https://pichost.netlify.app/blog/656037f5b07ba.webp&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;p&gt;下面的部分根据自己需要选择：&lt;/p&gt;
&lt;h3&gt;如果你不使用自己的域名&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;删除仓库中的&lt;code&gt;CNAME&lt;/code&gt;文件&lt;/li&gt;
&lt;li&gt;把&lt;code&gt;404.html&lt;/code&gt;文件中的&lt;code&gt;var PATH_SEGMENTS_TO_SKIP = 0;&lt;/code&gt;改为&lt;code&gt;var PATH_SEGMENTS_TO_SKIP = 1;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;到这里就结束了，你可以直接跳到&lt;a href=&quot;#%E6%B5%8B%E8%AF%95%E6%95%88%E6%9E%9C&quot;&gt;下一部分&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;如果你用了自己的域名&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;到你的域名服务商，添加一个 CNAME 解析，域名指向&lt;code&gt;username.github.io&lt;/code&gt;，注意替换&lt;code&gt;username&lt;/code&gt;为自己的 GitHub 用户名&lt;/li&gt;
&lt;li&gt;等待几分钟（域名解析生效需要时间，所以最好提前做），再进入到 github pages 部分，键入你自己的域名，最好勾选&lt;strong&gt;Enforce HTTPS&lt;/strong&gt;，然后点击&lt;code&gt;Save&lt;/code&gt;，刷新页面，会显示下面的内容:
&lt;img src=&quot;https://pichost.netlify.app/blog/65603a508e30d.webp&quot; alt=&quot;image&quot; /&gt;&lt;/li&gt;
&lt;li&gt;把&lt;code&gt;CNAME&lt;/code&gt;文件中的域名更改为你配置好的域名&lt;/li&gt;
&lt;li&gt;到此，就配置完成了，接下来可以测试一下&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;测试效果&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;在你开始作为数据库的 GitHub 仓库创建一个 issue，标题就是你需要缩短的链接，其他什么都不需要做，直接 Submit 就行了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;等待一会儿，然后在浏览器查询链接&lt;code&gt;https://&amp;lt;your-domain&amp;gt;/&amp;lt;issue-no&amp;gt;&lt;/code&gt;。例如：&lt;code&gt;https://tldr.plus/2&lt;/code&gt;，点击这个链接会跳转到我的博客。其中的&lt;code&gt;tldr.plus&lt;/code&gt;是我的域名，&lt;code&gt;1&lt;/code&gt;代表 issue 的楼层数。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;如果大家觉得麻烦，也可以使用我搭建的服务，你可以点击&lt;a href=&quot;https://github.com/baddate/url_shortener_db/issues/new&quot;&gt;这里&lt;/a&gt;提供链接。&lt;/p&gt;
&lt;p&gt;有人在&lt;a href=&quot;https://github.com/nelsontky/gh-pages-url-shortener/issues/5#issuecomment-728040879&quot;&gt;这里&lt;/a&gt;给了一个比较好的解释，大家可以参考一下。&lt;/p&gt;
&lt;h2&gt;参考&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/nelsontky/gh-pages-url-shortener&quot;&gt;https://github.com/nelsontky/gh-pages-url-shortener&lt;/a&gt;&lt;/p&gt;
</content:encoded></item><item><title>Build site with Franklin.jl</title><link>https://smj.im/blag/posts/build-site-with-franklin/</link><guid isPermaLink="true">https://smj.im/blag/posts/build-site-with-franklin/</guid><pubDate>Tue, 03 Nov 2020 11:03:03 GMT</pubDate><content:encoded>&lt;h2&gt;Forward&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://franklinjl.org/&quot;&gt;Franklin.jl&lt;/a&gt; is a simple, customisable static site generator oriented towards technical blogging and light, fast-loading pages.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;At first, I want to learning Julia with a small open source project, smaller and better. Then I search on github with topic&lt;code&gt;#julia&lt;/code&gt;, and I find this tool. As I learned about it on its site, I think I can use this for my massively personal site(maybe it is beautiful, but too complex), and learning Julia when rebuilding my site.&lt;/p&gt;
&lt;p&gt;Therefore, I write this tutorial as my beginning.&lt;/p&gt;
&lt;p&gt;Last but not least, Franklin.jl has many features:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Augmented markdown allowing definition of LaTeX-like commands,&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Easy inclusion of user-defined div-blocks,&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Maths rendered via KaTeX, code via highlight.js both can be pre-rendered,&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Can live-evaluate Julia code blocks,&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Live preview of modifications,&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Simple optimisation step to compress and pre-render the website,&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Simple publication step to deploy the website,&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Straightforward integration with Literate.jl.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Setup Environment&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;Download Julia from &lt;a href=&quot;https://julialang.org/downloads/&quot;&gt;official site&lt;/a&gt; for your OS.&lt;/li&gt;
&lt;li&gt;Install it.&lt;/li&gt;
&lt;li&gt;Open julia REPL.&lt;/li&gt;
&lt;li&gt;Then excute &lt;code&gt;using Pkg; Pkg.add(Franklin)&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;Start building&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;New a site with the following scripts:&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;julia&amp;gt; using Franklin
julia&amp;gt; newsite(&quot;mySite&quot;, template=&quot;pure-sm&quot;)
✓ Website folder generated at &quot;mySite&quot; (now the current directory).
→ Use serve() from Franklin to see the website in your browser.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Once you excuted the command above, this Julia REPL workspace will be in your site folder.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Start local server for debug:&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;julia&amp;gt; serve()
→ Initial full pass...
→ Starting the server...
✓ LiveServer listening on http://localhost:8000/ ...
  (use CTRL+C to shut down)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;you can get this page in your browser:
&lt;img src=&quot;https://pichost.netlify.app/blog/65603785435ed.webp&quot; alt=&quot;Franklin Example&quot; /&gt;
&lt;em&gt;note: this &lt;code&gt;mySite&lt;/code&gt; folder will be created in your current directory. You can check your current directory with&lt;code&gt;pwd()&lt;/code&gt;.&lt;/em&gt;&lt;/p&gt;
&lt;h2&gt;Site Structure&lt;/h2&gt;
&lt;h3&gt;Page structure&lt;/h3&gt;
&lt;p&gt;your &lt;code&gt;mySite&lt;/code&gt; folder structure like this:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;├─.github
│  └─workflows
├─_assets
│  └─scripts
│      └─output
├─_css
├─_layout
├─_libs
│  ├─highlight
│  ├─katex
│  │  └─fonts
│  └─pure
└─__site
    ├─assets
    │  ├─menu1
    │  │  ├─code
    │  │  │  └─output
    │  │  └─output
    │  └─scripts
    │      └─output
    ├─css
    ├─layout
    ├─libs
    │  ├─highlight
    │  ├─katex
    │  │  └─fonts
    │  └─pure
    ├─menu1
    ├─menu2
    ├─menu3
    └─tag
        ├─code
        ├─image
        └─syntax
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;.github&lt;/code&gt; folder is generated for Github Actions, you can config some fields for your customization.Fox example, you can change trigger branch from &lt;code&gt;dev&lt;/code&gt; to your &lt;strong&gt;workspace branch&lt;/strong&gt; like &lt;code&gt;master&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;name: Build and Deploy
on:
  push:
    branches:
-      - dev
+      - master
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Then you should change another &lt;strong&gt;BRANCH&lt;/strong&gt;(I named it as site branch) field here:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    - name: Build and Deploy
      uses: JamesIves/github-pages-deploy-action@releases/v3
      with:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
-       BRANCH: master
+       BRANCH: dev
        FOLDER: __site
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;NOTE: you must keep the site branch &lt;strong&gt;different from&lt;/strong&gt; the workspace branch(in the case it&apos;s &lt;code&gt;master&lt;/code&gt;), because you site files will be generated on &lt;code&gt;dev&lt;/code&gt; branch&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;If you use config above, your &lt;code&gt;master&lt;/code&gt; branch is your workspace branch and your &lt;code&gt;dev&lt;/code&gt; branch is your Github Pages site branch.&lt;/p&gt;
&lt;h2&gt;Deploying on GitHub&lt;/h2&gt;
&lt;h3&gt;local config&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Create a personal repo on github, named &lt;code&gt;username.github.io&lt;/code&gt;, or you can name it whatever you want to if you have a domain.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Open local folder you created with Franklin before with bash or any other shell.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Follow these steps below to config your repo: &lt;br /&gt;
i)&lt;code&gt;git remote add origin URL_TO_YOUR_REPO&lt;/code&gt; &lt;br /&gt;
ii)&lt;code&gt;git add . &amp;amp;&amp;amp; git commit -m &quot;initial files&quot;&lt;/code&gt; &lt;br /&gt;
iii)&lt;code&gt;git push -u origin master&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;github config&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Open &lt;code&gt;Settings&lt;/code&gt; on your repo page, and scrolling down until you find &lt;code&gt;GitHub Pages&lt;/code&gt; option.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Config it as below:
&lt;img src=&quot;https://pichost.netlify.app/blog/656037f2073ea.webp&quot; alt=&quot;Github Pages on Settings&quot; /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;note: you must make the branch __same__ as the **site branch** in the `deploy.yml`
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;DONE!&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;You can find some examples of websites using Franklin.jl from &lt;a href=&quot;https://github.com/tlienart/Franklin.jl&quot;&gt;Franklin.jl&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;By the way, I following this &lt;a href=&quot;https://abhishalya.github.io/&quot;&gt;blog site&lt;/a&gt; as templates and customizing it. It is a very simple and wonderful site.&lt;/p&gt;
&lt;p&gt;Please email me if there are any errors.&lt;/p&gt;
&lt;h2&gt;REFERENCE&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://franklinjl.org/&quot;&gt;https://franklinjl.org/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/abhishalya/abhishalya.github.io&quot;&gt;https://github.com/abhishalya/abhishalya.github.io&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.github.com/en/free-pro-team@latest/github/working-with-github-pages&quot;&gt;https://docs.github.com/&lt;/a&gt;&lt;/p&gt;
</content:encoded></item><item><title>iwd的使用教程</title><link>https://smj.im/blag/posts/iwd-tutorial/</link><guid isPermaLink="true">https://smj.im/blag/posts/iwd-tutorial/</guid><pubDate>Mon, 05 Oct 2020 09:31:36 GMT</pubDate><content:encoded>&lt;h2&gt;&lt;strong&gt;介绍&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;iNet Wireless Daemon&lt;/strong&gt;（iwd） 项目旨在为基于 Linux 的设备提供全面的 Wi-Fi 连接解决方案，由 Intel 团队进行维护开发。该项目的核心目标是通过不依赖于任何外部库，并最大限度地利用 Linux 内核提供的功能来优化资源利用率：存储、运行时内存和链路时间成本。是一个仅依赖于 Linux 内核和运行时 C 库的自包含环境（self-contained environment）。 项目架构 iwd 的基本架构如下图所示：&lt;/p&gt;
&lt;p&gt;iwd 需要使用 ell（Embedded Learning Library）这个库来进行编译守护进程和控制实用程序的开发版本。 iwd 将 Linux 内核的 crypto 子系统用于所有加密操作，不使用&lt;em&gt;OpenSSL&lt;/em&gt;或任何其他用户空间加密库。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pichost.netlify.app/blog/6560384cd1ebc.webp&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;安装&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;直接使用各个发行版自带的包管理器下载即可，这里以 arch 系的&lt;code&gt;pacman&lt;/code&gt;为例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    pacman -S iwd
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;安装完软件包之后，直接使用&lt;code&gt;systemctl enable iwd.service&lt;/code&gt;命令启动 iwd 服务。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;基本使用方法&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;启动&lt;code&gt;iwctl&lt;/code&gt; 键入以下命令进入交互式命令行：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    $ iwctl
    [iwd]#
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意：这里的&lt;code&gt;[iwd]#&lt;/code&gt;是交互式命令行的提示符。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;连接到网络&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;首先，如果你不知道无线设备名称，使用下面的命令列出所有 Wi-Fi 设备：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    [iwd]# device list
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后，要扫描网络：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    [iwd]# station device scan
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后，您可以列出所有可用的网络：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    [iwd]# station device get-networks
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最后，要连接到网络：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    [iwd]# station device connect SSID
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果你想要手动断开网络链接，使用以下命令：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    [iwd]# station device disconnect
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;要列出以前已连接到的网络：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    [iwd]# known-networks list
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;要忘记已知网络：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    [iwd]# known-networks SSID forget
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;要显示 WiFi 设备的详细信息（如 MAC 地址）：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    [iwd]# device device show
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;要显示连接状态，包括 Wi-Fi 设备的连接网络：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    [iwd]# station device show
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果你想进行其他操作，可以在交互式命令行中输入&lt;code&gt;help&lt;/code&gt;获取帮助信息。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;进阶使用&lt;/strong&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;strong&gt;使用内置的网络配置&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;iwd 内置&lt;strong&gt;DHCP 客户端以及静态配置 IP 地址&lt;/strong&gt;的功能，所以你可以不用使用独立的 dhcpd 软件包来管理网络。 如果使用 iwd 的网络配置功能，需要编辑&lt;code&gt;/etc/iwd/main.conf&lt;/code&gt;并添加以下部分（如果不存在就手动创建）：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    [General]
    EnableNetworkConfiguration=true
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;&lt;strong&gt;MAC 地址随机化&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;01. 基本方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;IWD 在版本初期已经支持将 MAC 地址随机化了，不过刚开始在 IWD 的整个生命周期内仅对地址随机化了一次。在 1.6 版本中，添加了基于每个网络的随机地址的功能。这个功能可以在 IWD 的主配置文件（默认为&lt;code&gt;/etc/iwd/main.conf&lt;/code&gt;）中启用此功能：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    # main.conf
    [General]
    AddressRandomization=network
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;p.s.如果设置&lt;em&gt;AddressRandomization=once__，MAC 地址只在 iwd 启动或硬件启动时第一次被检测到时随机化一次&lt;/em&gt;；如果设置 AddressRandomization=disabled，显而易见，就是不隐藏 MAC 地址，使用真实地 MAC 地址。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;其实这个时候的 MAC 地址并不是真正意义上的随机，而是伪随机，因为这个 MAC 地址是使用 SHA256 摘要从永久适配器地址和所连接的 SSID 生成的--这也就意味着，如果使用同一个网络所随机化生成的 MAC 地址是一样的。通常来说，对于普通用户来说已经足够了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;02. 高级方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果你想使用 IWD 来完全随机化你的 MAC 地址，那么可以使用&lt;code&gt;AlwaysRandomizeAddress&lt;/code&gt;选项来生成。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    AlwaysRandomizeAddress=true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;下面列举一些常用网络配置选项：![常用网络配置选项](/media/editor/Screenshot 2023-01-14 222054_20230114222118417000.png)&lt;strong&gt;03. 设定随机化范围&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;iwd 配置中还有一个&lt;code&gt;AddressRandomizationRange&lt;/code&gt;选项，用来控制地址的哪一部分是随机化的，那一部分是真实的。&lt;/p&gt;
&lt;p&gt;当你把“&lt;code&gt;AddressRandomizationRange&lt;/code&gt;”设置为“&lt;code&gt;nic&lt;/code&gt;”时，仅 NIC 特定的字节（最后&lt;strong&gt;3 个&lt;/strong&gt;字节）是随机的。有一点要注意，随机范围限制为 00:00:01 至 00：00：FE。物理网卡的 mac 地址用于前 3 个字节。&lt;/p&gt;
&lt;p&gt;当使用“&lt;code&gt;AddressRandomizationRange&lt;/code&gt;”设置为“&lt;code&gt;full&lt;/code&gt;”时，MAC 地址的 6 个字节都是随机&lt;/p&gt;
</content:encoded></item><item><title>超好用的UML工具推荐</title><link>https://smj.im/blag/posts/powerful-uml-tools/</link><guid isPermaLink="true">https://smj.im/blag/posts/powerful-uml-tools/</guid><pubDate>Sun, 04 Oct 2020 02:36:28 GMT</pubDate><content:encoded>&lt;p&gt;废话不说, 直入主题&lt;/p&gt;
&lt;h2&gt;draw.io&lt;/h2&gt;
&lt;p&gt;这个是我一直在用的一个在线 UML 工具，超级好用。 支持多种导入格式：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pichost.netlify.app/blog/65671160f1daa.webp&quot; alt=&quot;1701253417977.webp&quot; /&gt;&lt;/p&gt;
&lt;p&gt;当然还支持导出，如果你想自定义一些导出参数，选择 advanced 选项进行导出前的配置：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pichost.netlify.app/blog/6567118fbfb53.webp&quot; alt=&quot;1701253509237.webp&quot; /&gt;&lt;/p&gt;
&lt;p&gt;支持多种存储方式：&lt;strong&gt;Google Drive&lt;/strong&gt;、&lt;strong&gt;Onedrive&lt;/strong&gt;、&lt;strong&gt;Dropbox&lt;/strong&gt;、&lt;strong&gt;GitHub&lt;/strong&gt;、&lt;strong&gt;GitLab&lt;/strong&gt;以及&lt;strong&gt;存储到本地&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pichost.netlify.app/blog/656711b35cf9a.webp&quot; alt=&quot;1701253552563.webp&quot; /&gt;&lt;/p&gt;
&lt;p&gt;支持各种形状，不仅可以画电路图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pichost.netlify.app/blog/656711d1cd9ca.webp&quot; alt=&quot;1701253580545.webp&quot; /&gt;&lt;/p&gt;
&lt;p&gt;还支持手绘风格的流程图，字体的话，可以通过更换字体格式为 Comic Sans MS 来实现手写体：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pichost.netlify.app/blog/656711f25720b.webp&quot; alt=&quot;1701253614499.webp&quot; /&gt;&lt;/p&gt;
&lt;p&gt;最最最强大的是，现在还&lt;strong&gt;支持导入.VSDX 文件&lt;/strong&gt;来进行编辑，不过导出还有点问题，过一段时间更新了应该就解决这个 bug 了。 之前只有 web 版，最近好像又更新出了桌面版，网站一直在推荐，大致看了看介绍，感觉就是把 web 封装起来了，不过还没用过，不知道体验怎么样，毕竟 web 版已经满足我的所有需求了:)&lt;/p&gt;
&lt;h2&gt;Excalidraw&lt;/h2&gt;
&lt;p&gt;这个之前写文章的时候经常用，功能比较简单，只支持简单的导入导出，而且还有一个最大的特点（其实也算缺点）只支持手绘风格，支持中文，但是中文字体不是手绘体，换句话说，就是只支持英文的手写体。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pichost.netlify.app/blog/6567120441936.webp&quot; alt=&quot;1701253631626.webp&quot; /&gt;&lt;/p&gt;
&lt;p&gt;如果要导入的话，支持.json 格式以及.ezcalidraw 格式的文件导入，虽然比较少，但是呢，其实使用这个也绘制不了太复杂的图，而且一般用这个也是即画即用、即用即画。即使你想之后再绘制或者更改，使用工具自带的.ezcalidraw 这个格式也够用了。支持导出的格式也只支持 PNG、SVG，哦，还支持剪切板导出，如果你想，还能加个官方水印。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pichost.netlify.app/blog/65671215a6fed.webp&quot; alt=&quot;1701253648748.webp&quot; /&gt;&lt;/p&gt;
&lt;p&gt;导出界面&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pichost.netlify.app/blog/6567122a735ec.webp&quot; alt=&quot;1701253670884.webp&quot; /&gt;&lt;/p&gt;
&lt;p&gt;剪切板导出效果&lt;/p&gt;
&lt;p&gt;比较惊喜的是，还支持链接共享，不过不知道链接有效期是多久，个人猜测应该是永久有效的吧，毕竟是加密上传到服务器的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pichost.netlify.app/blog/6567123e91b7a.webp&quot; alt=&quot;1701253689851.webp&quot; /&gt;&lt;/p&gt;
&lt;p&gt;链接分享界面&lt;/p&gt;
&lt;p&gt;下面的链接是我测试的用例，有兴趣的童鞋可以点下看看是不是还在： &lt;a href=&quot;https://excalidraw.com/#json=5748441833537536,nnQpSKFk4pLbb209saLfEg&quot;&gt;https://excalidraw.com/#json=5748441833537536,nnQpSKFk4pLbb209saLfEg&lt;/a&gt;
最最最让人意外的是，竟然还&lt;strong&gt;支持多人协作&lt;/strong&gt;！！！这是最让我意外的的一个功能好吧，我只能说，太强了！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pichost.netlify.app/blog/6567126e970c0.webp&quot; alt=&quot;1701253730403.webp&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;ASCII FLOW&lt;/h2&gt;
&lt;p&gt;一个文字风格的制图软件，功能及其简约，你能想到的冗余功能这里一个都没有。有些你需要高级功能，这里其实也没有。。。所以我为什么还要推荐它呢，我比较喜欢的一点就是，比较独特的 ASCII 风格。而且，绘制时的动画及手感也让我很喜欢，最重要的一点是，这个界面对我来说也极具吸引力！不过这点可能因人而异，但我觉得你只要用它，就会体会到它的魅力。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pichost.netlify.app/blog/656712b2a709c.webp&quot; alt=&quot;1701253806723.webp&quot; /&gt;&lt;/p&gt;
&lt;p&gt;不过比较遗憾的一点吧算是，这个工具&lt;em&gt;对中文支持不太好&lt;/em&gt;，如果连续输入多个汉字就会挤在一起，但是一个一个输入没问题 🙄，主要是因为汉字太宽了，要占 2 格才能显示完全，所以连续输入会重叠在一起。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pichost.netlify.app/blog/656712d7aa2aa.webp&quot; alt=&quot;1701253838826.webp&quot; /&gt;&lt;/p&gt;
&lt;p&gt;当然，如果你不喜欢这种 ASCII 风格的框线，你可以自己在这里更改：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pichost.netlify.app/blog/656712e56d2e3.webp&quot; alt=&quot;1701253859885.webp&quot; /&gt;&lt;/p&gt;
&lt;p&gt;注意一点，如果你要拖动画面更改聚焦点的话，需要先按着 CTRL 键再拖动鼠标才行。其他一些技巧，你可以点击界面右上角的 ❓ 来自己了解。 btw，上面提到的工具都是&lt;strong&gt;开源&lt;/strong&gt;的哦，至于地址，emmm，你猜在哪？我不会告诉你在文末的!&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;有些人可能觉得微软的 Visio 也很强大啊，为什么不推荐呢？是的，我知道啊，但是我就不推荐，你奈我何？？ 哈哈哈，开个玩笑哈，我不推荐用这个，只是因为它是要&lt;strong&gt;收费&lt;/strong&gt;的啊，你总不能让我用盗版吧？我可不是那样的人呢(手动狗头。而且，Visio 太臃肿了(学校的教育版)！！！不适合我这种追求极简生活的人。&lt;/p&gt;
</content:encoded></item><item><title>ArchLinux安装配置笔记 (Updated)</title><link>https://smj.im/blag/posts/archlinux-installation-guide/</link><guid isPermaLink="true">https://smj.im/blag/posts/archlinux-installation-guide/</guid><description>一篇详尽的Arch Linux安装指南以及安装过程的踩坑记录。</description><pubDate>Sun, 05 Jul 2020 01:14:36 GMT</pubDate><content:encoded>&lt;p&gt;import BlogPostCard from &apos;@components/BlogPostCard.astro&apos;&lt;/p&gt;
&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;自从 3 月份从 Arch 换到 Fedora 系统之后，刚开始感觉还不错，因为大部分东西都已经帮你搞定了，自己只要会用就可以了，但是用的久了，感觉 Fedora 的软件包管理器真心不如 Arch 的 pacman 好用，有些中文软件在仓库中根本找不到，自己配置起来很麻烦，但是如果用 Arch 的话，构建起来就很简单了，所以最终还是决定重新拥抱 Arch。
刚一开始我还准备按照我之前总结的安装记录进行安装，毕竟当时记录的还是很详细的，但是没想到刚进入 Live 系统就碰到了一个难题：&lt;code&gt;wifi-menu&lt;/code&gt;命令不存在！ ！ EXCUSE ME?? 我明明验证过镜像完整性的，没问题啊，这是怎么回事？还好，机智的我知道这里面有问题，查阅了一点资料之后就发现(这里不得不吹一波 Arch 的用户社区，真心给力，盲猜是最活跃的 Linux 发行版社区)原来是官方弃用了，改用&lt;code&gt;iwd&lt;/code&gt;+&lt;code&gt;systemd-networkd&lt;/code&gt;来管理网络了，莫得办法，那就换吧，查了查 iwd 的基本命令使用，发现还挺简单的，一次配置，永久使用，比&lt;code&gt; wifi-menu&lt;/code&gt;用起来要流畅许多！&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;archlinux 的 iso 镜像文件自 2020.06.01 开始改了很多东西，大概就这几个方面：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;archiso 默认的 shell 是 zsh，不再是 bash 了。&lt;/li&gt;
&lt;li&gt;archlinux 摒弃了之前的&lt;code&gt;wifi-menu&lt;/code&gt;，改为使用 iwd 来管理网络。&lt;/li&gt;
&lt;li&gt;对于镜像源的管理，采用 reflector 进行管理，终于不用去手动更改镜像源的位置了，使用 reflector 一条命令就搞定了。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;必需条件&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;一台可以使用的电脑&lt;/li&gt;
&lt;li&gt;一个 4G 以上内存的 USB 存储器&lt;/li&gt;
&lt;li&gt;一个可以查看本文的电子设备:)&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;制作 USB 启动盘&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;首先在&lt;a href=&quot;https://www.archlinux.org/download/&quot;&gt;这里&lt;/a&gt;找一个延迟低的官方镜像站下载 ArchLinux 的 iso 镜像，我下载的是最新版本，参数如下:&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;Current Release: 2020.07.01&lt;/li&gt;
&lt;li&gt;Included Kernel: 5.7.6&lt;/li&gt;
&lt;li&gt;ISO Size: 647.0 MB&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;在镜像站下载 PGP 签名，然后使用&lt;code&gt;gpg&lt;/code&gt;验证签名确保镜像完整性以及安全性，命令如下: &lt;code&gt;gpg --keyserver-options auto-key-retrieve --verify archlinux-version-x86_64.iso. sig&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;然后使用磁盘烧录工具将镜像写入你的 USB 存储器。 Linux 系统建议使用&lt;code&gt;dd&lt;/code&gt;这个神器。 Windows 系统的话，建议使用开源软件&lt;code&gt;rufus&lt;/code&gt;，最好不要使用那个 UltralISO，很容易出问题。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;开始安装&lt;/h2&gt;
&lt;h3&gt;验证启动模式&lt;/h3&gt;
&lt;p&gt;进入 Live 环境然后验证你的机器的启动模式是 UEFI 还是 BIOS 模式，以下方式二选一：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 有输出说明是UEFI模式
ls /sys/firmware/efi/efivars

# 输出64/32说明是对应的UEFI模式，否则是BIOS模式
cat /sys/firmware/efi/fw_platform_size
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;连接网络&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;前面已经说过了，Archiso 的默认的无线网络管理改为&lt;code&gt;iwd&lt;/code&gt;了，所以这里就讲一下如何使用 &lt;code&gt;iwd&lt;/code&gt; 连接 wifi&lt;/em&gt;，如果想深入了解一下&lt;code&gt;iwd&lt;/code&gt;，可以参考我写的另一篇文章&lt;/p&gt;
&lt;p&gt;&amp;lt;BlogPostCard slug=&quot;iwd-tutorial&quot; hideImage /&amp;gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在终端中输入&lt;code&gt;iwctl&lt;/code&gt;进入 iwd 提示符：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;[root@archiso~] iwctl
[iwd#]
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;在&lt;code&gt;[iwd#]&lt;/code&gt;中输入&lt;code&gt;device list&lt;/code&gt;查询机器的网卡设备。&lt;/li&gt;
&lt;li&gt;使用以下命令查询附近可用的 wifi 网络：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;[iwd#] station &amp;lt;devicename&amp;gt; scan
[iwd#] station &amp;lt;devicename&amp;gt; get-networks # 显示扫描的结果
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;在提示符中输入&lt;code&gt;station &amp;lt;devicename&amp;gt; connect &amp;lt;wifi-ssid&amp;gt;&lt;/code&gt;连接 wifi 网络，如果 wifi 加密，会提示你输入密码&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;更新系统时间&lt;/h3&gt;
&lt;p&gt;使用&lt;code&gt;timedatectl&lt;/code&gt;命令来确保时间是同步的：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;timedatectl set-ntp true
timedatectl status # 确保设置成功
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;磁盘分区&lt;/h3&gt;
&lt;p&gt;首先使用&lt;code&gt;lsblk&lt;/code&gt;或者其他磁盘工具（例如&lt;code&gt;fdisk&lt;/code&gt;）查看磁盘设备：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;lsblk
// or
fdisk -l
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后使用&lt;code&gt;fdisk&lt;/code&gt;或者&lt;code&gt;cfdisk&lt;/code&gt;创建磁盘分区，这里有一点要注意的是，在创建分区的时候， &lt;strong&gt;必需要确保有一个 root 分区&lt;code&gt;/&lt;/code&gt;&lt;/strong&gt; ，此外，对于 UEFI 模式的设备还需要一个额外的 EFI 系统分区，我的分区方式如下：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;挂载点&lt;/th&gt;
&lt;th&gt;分区类型&lt;/th&gt;
&lt;th&gt;大小&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;/mnt/boot&lt;/td&gt;
&lt;td&gt;EFI system partition&lt;/td&gt;
&lt;td&gt;1G&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/mnt&lt;/td&gt;
&lt;td&gt;Linux x86-64 root&lt;/td&gt;
&lt;td&gt;32G&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;swap&lt;/td&gt;
&lt;td&gt;Linux swap&lt;/td&gt;
&lt;td&gt;16G&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/home&lt;/td&gt;
&lt;td&gt;Linux home&lt;/td&gt;
&lt;td&gt;Remainder of the device&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;无论是&lt;code&gt;fdisk&lt;/code&gt;还是&lt;code&gt;cfdisk&lt;/code&gt;，用起来都很简单，所以这里不再具体介绍了，想要具体了解的可以查阅&lt;a href=&quot;https://wiki.archlinux.org/index.php/Fdisk&quot;&gt;fdisk 官方文档&lt;/a&gt;、&lt;a href=&quot;https://wiki.archlinux.org/index.php/Cfdisk&quot;&gt;cfdisk 官方文档&lt;/a&gt;。对于新人小白，个人推荐&lt;code&gt;cfdisk&lt;/code&gt;，有一个伪图形界面，很容易上手。&lt;/p&gt;
&lt;h3&gt;格式化分区&lt;/h3&gt;
&lt;p&gt;按照上面的步骤建立好分区之后，我们需要将每个分区用对应的文件系统进行格式化。&lt;/p&gt;
&lt;p&gt;我的分区名称对应的挂载点&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;挂载点&lt;/th&gt;
&lt;th&gt;分区名称&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;/mnt/boot&lt;/td&gt;
&lt;td&gt;/dev/sda1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/mnt&lt;/td&gt;
&lt;td&gt;/dev/sda2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;swap&lt;/td&gt;
&lt;td&gt;/dev/sda3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/home&lt;/td&gt;
&lt;td&gt;/dev/sda4&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;对于 root 分区、home 分区等直接使用&lt;code&gt;ext4&lt;/code&gt;文件系统进行初始化：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mkfs.ext4 /dev/sda2
mkfs.ext4 /dev/sda4
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果你的机器是 UEFI 启动模式，使用以下命令初始化 EFI 系统分区：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mkfs.fat -F32 /dev/sda1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对于交换分区，不能使用上述命令进行格式化，而需要使用&lt;code&gt;mkswap&lt;/code&gt;将其初始化：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mkswap /dev/sda3
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;挂载分区&lt;/h3&gt;
&lt;p&gt;首先挂载&lt;code&gt;root&lt;/code&gt;分区：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mount /dev/sda2 /mnt
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对于其他分区（swap 分区除外，不需要），需要自己手动创建挂载点：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mount --mkdir /dev/sda1 /mnt/boot
mount --mkdir /dev/sda4 /mnt/home
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;挂载交换分区：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;swapon /dev/sda3
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;选择镜像源&lt;/h3&gt;
&lt;p&gt;文件&lt;code&gt;/etc/sudo pacman.d/mirrorlist&lt;/code&gt;定义了软件包会从哪个镜像源下载。&lt;s&gt;在 Live 启动的系统上，所有的镜像都被启用。&lt;/s&gt; 在列表中越前的镜像在下载软件包时有越高的优先权。你可以相应的修改文件&lt;code&gt;/etc/sudo pacman.d/mirrorlist&lt;/code&gt;，并将地理位置最近的镜像源挪到文件的头部来保证下载速度。而且这个文件接下来还会被 pacstrap 拷贝到新系统里，在这里设置好之后就可以一劳永逸了。&lt;/p&gt;
&lt;p&gt;手动修改文件或者可以使用 &lt;code&gt;reflector&lt;/code&gt;，执行下面的命令会自动修改mirrorlist：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;reflector -c cn -p https --ipv4 -l 5 --save /etc/sudo pacman.d/mirrorlist
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;[!NOTE]
感觉这一步其实现在可以省略了，因为现在在 live 环境中使用&lt;code&gt;reflector&lt;/code&gt;进行镜像的管理，貌似你一连接网络，live 系统会自动执行 reflector 命令来帮你选择镜像源，默认的是根据下载速率进行排序，感兴趣的小伙伴可以自己确认一下（连接网络之前备份一下&lt;code&gt;/etc/sudo pacman.d/mirrorlist&lt;/code&gt;文件，然后连接网络之后，使用&lt;code&gt;diff&lt;/code&gt;对比前后两个文件的差异）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;安装必需软件包&lt;/h3&gt;
&lt;p&gt;使用 archiso 内置的脚本&lt;code&gt;pacstrap&lt;/code&gt;安装一些基本的软件包、内核及常规的硬件固件：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;pacstrap /mnt base linux linux-firmware base-devel
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;这里要注意的是，上面的命令并不包括所有的基本程序，如网络管理程序、文本编辑器等，如果你想安装这些程序，可以将名字添加到&lt;code&gt;pacstrap&lt;/code&gt;后，并用空格隔开。你也可以在 Chroot 进新系统后使用&lt;code&gt;pacman&lt;/code&gt;手动安装软件包或组。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;配置系统&lt;/h3&gt;
&lt;h4&gt;生成 fstab 文件&lt;/h4&gt;
&lt;p&gt;用以下命令生成&lt;code&gt;fstab&lt;/code&gt;文件，其中&lt;code&gt;-U&lt;/code&gt;选项用来设置 UUID：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;genfstab -U /mnt &amp;gt;&amp;gt; /mnt/etc/fstab
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后使用&lt;code&gt;cat /mnt/etc/fstab&lt;/code&gt;命令检查以下文件是否正确（每个分区占一行，查看是否包含所有分区）&lt;/p&gt;
&lt;h4&gt;进入到安装的系统&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;arch-chroot /mnt
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;安装文本编辑器&lt;/h4&gt;
&lt;p&gt;现在的新系统连默认的文本编辑器&lt;code&gt;nano&lt;/code&gt;都没有了，所以需要自己手动安装一个，不然后面的一些配置无法实现，所以我选择最强的&lt;code&gt;vim&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;pacman -S vim
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;时区&lt;/h4&gt;
&lt;p&gt;使用下面的命令设置时区：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ln -sf /usr/share/zoneinfo/Region/City /etc/localtime
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后使用&lt;code&gt;hwclock&lt;/code&gt;生成&lt;code&gt;/etc/adjtime&lt;/code&gt;文件：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;hwclock --systohc
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;本地化设置&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;本地化的程序与库若要本地化文本，都依赖&lt;a href=&quot;https://wiki.archlinux.org/index.php/Locale&quot;&gt;Locale&lt;/a&gt;，后者明确规定地域、货币、时区日期的格式、字符排列方式和其他本地化标准等等。在下面两个文件设置：&lt;code&gt;locale.gen&lt;/code&gt;与&lt;code&gt;locale.conf&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;首先编辑&lt;code&gt;/etc/locale.gen&lt;/code&gt;文件，然后将需要的地区的注释移除，建议将&lt;code&gt;en_US UTF-8&lt;/code&gt;和&lt;code&gt;zh_CN UTF-8&lt;/code&gt;都取消注释。&lt;/li&gt;
&lt;li&gt;执行&lt;code&gt;locale-gen&lt;/code&gt;命令生成 locale。&lt;/li&gt;
&lt;li&gt;创建&lt;code&gt;locale.conf&lt;/code&gt;文件并编辑&lt;code&gt;LANG&lt;/code&gt;这一变量（将系统 locale 设置为&lt;code&gt;en_US.UTF-8&lt;/code&gt;，系统的&lt;code&gt;Log&lt;/code&gt;就会用英文显示，这样更容易问题的判断和处理。）：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;LANG=en_US.UTF-8
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;这里最好不要设置为中文 locale，会导致 TTY 乱码&lt;/em&gt;&lt;/p&gt;
&lt;h4&gt;网络设置&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;创建&lt;code&gt;/etc/hostname&lt;/code&gt;文件设置主机名&lt;/li&gt;
&lt;li&gt;配置&lt;code&gt;/etc/hosts&lt;/code&gt;文件，将以下内容添加进去：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;127.0.0.1 localhost
::1 localhost
127.0.1.1 myhostname.localdomain myhostname
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;note: 如果系统有一个永久的 IP 地址，请使用这个永久的 IP 地址而不是 127.0.1.1。&lt;/em&gt;&lt;/p&gt;
&lt;h4&gt;设置 root 密码&lt;/h4&gt;
&lt;p&gt;使用&lt;code&gt;passwd&lt;/code&gt;命令设置 root 密码即可。&lt;/p&gt;
&lt;p&gt;这里不得不说一句，使用 arch 是真的让人舒服的一批，不会出现一些令人无语的问题，我还记得第一次使用 linux 的时候，用的是 fedora，当时想要使用&lt;code&gt;su &lt;/code&gt;进入 root，但是发现需要密码，但是我不记得安装的时候设置过 root 密码啊，后来查阅了一些资料才发现，fedora 并没有设置 root 密码，需要自己手动设置（使用&lt;code&gt;sudo passwd root&lt;/code&gt;）。&lt;/p&gt;
&lt;h4&gt;安装及配置引导程序&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;[!IMPORTANT]
安装引导程序之后才能进入系统&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5&gt;微码更新&lt;/h5&gt;
&lt;p&gt;安装GRUB&lt;strong&gt;之前&lt;/strong&gt;建议安装对应CPU的ucode，例如我的是amd的CPU，所以安装的是：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;pacman -S amd-ucode
# 如果是Intel的CPU
pacman -S intel-ucode
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样在下面生成GRUB的配置文件的时候，会包含进去这部分。&lt;/p&gt;
&lt;h5&gt;GRUB 引导程序&lt;/h5&gt;
&lt;p&gt;我用的引导程序是&lt;a href=&quot;https://wiki.archlinux.org/index.php/GRUB&quot;&gt;GRUB&lt;/a&gt;，首先安装必要的软件包：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;pacman -S grub efibootmgr
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里详细介绍一下 UEFI 系统如何安装配置 GRUB：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;首先使用以下命令安装到系统：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;grub-install --target=x86_64-efi --efi-directory=/boot --bootloader-id=ArchLinux
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;note: 因为我的 EFI 分区在&lt;code&gt;/boot&lt;/code&gt;目录下，所以上述命令的&lt;code&gt;--efi-directory&lt;/code&gt;参数就设置为&lt;code&gt;/boot&lt;/code&gt;&lt;/em&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用&lt;code&gt;grub-mkconfig &lt;/code&gt;生成 grub 配置文件：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;grub-mkconfig -o /boot/grub/grub.cfg
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;安装 wifi 网络管理工具&lt;/h4&gt;
&lt;p&gt;推荐使用&lt;code&gt;iwd&lt;/code&gt;，命令简单方便又强大：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;pacman -S iwd
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;重启&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;输入&lt;code&gt;exit&lt;/code&gt;或按&lt;code&gt;Ctrl+d&lt;/code&gt;退出&lt;code&gt;chroot&lt;/code&gt;环境&lt;/li&gt;
&lt;li&gt;用&lt;code&gt;umount -R /mnt&lt;/code&gt;手动卸载被挂载的分区&lt;/li&gt;
&lt;li&gt;执行&lt;code&gt;reboot&lt;/code&gt;重启系统&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;再配置新系统&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;因为还没有设置普通用户，所以重启后需要使用 &lt;code&gt;root&lt;/code&gt; 来进入新系统&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;添加普通用户&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;使用以下命令添加一个用户&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;useradd -m -G &quot;附加组&quot; -s &quot;登陆shell&quot; &quot;用户名&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-m&lt;/code&gt;/&lt;code&gt;--create-home&lt;/code&gt;：创建用户主目录/home/[用户名]&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-G&lt;/code&gt;/&lt;code&gt;--groups&lt;/code&gt;：用户要加入的附加组列表；使用逗号分隔多个组，不要添加空格；如果不设置，用户仅仅加入初始同名组。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-s&lt;/code&gt;/&lt;code&gt;--shell&lt;/code&gt;：用户默认登录 shell 的路径&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;赋予用户 root 权限&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;安装 sudo 软件包: &lt;code&gt;sudo pacman -S sudo&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;在&lt;code&gt;/etc/sudoers&lt;/code&gt;文件中的&lt;code&gt;root ALL=(ALL) ALL&lt;/code&gt;行下添加&lt;code&gt;yourname ALL=(ALL) ALL&lt;/code&gt;，如果是多用户，可以加入&lt;code&gt;wheel&lt;/code&gt;组，赋予该组成员&lt;code&gt;sudo&lt;/code&gt;权限：&lt;code&gt;%wheel ALL=(ALL) ALL&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;配置网络&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;如果你没有安装 wifi 网络管理工具，或者你安装的工具需要 gui 支持，&lt;s&gt;那么恭喜你，你的系统还是无法联网，恭喜你可以重新体验一次完整的 archlinux 安装流程:)&lt;/s&gt;，则需要重新USB进入安装系统，&lt;code&gt;arch-chroot&lt;/code&gt;新系统然后安装一个 &lt;code&gt;Wi-Fi&lt;/code&gt; 网络管理工具。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;如果你按照我上面写的安装了 wifi 工具&lt;code&gt;iwd&lt;/code&gt;，那么你还需要做一些额外的工作才能正常使用它：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;启动 iwd 服务，为了以后的使用，建议直接设置为开机自启动，详细方法可以参考&lt;a href=&quot;https://wiki.archlinux.org/index.php/Systemd#Using_units&quot;&gt;systemd&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;systemctl start iwd.service # 启动服务
systemctl enable iwd.service # 开机自启动服务
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;因为 &lt;code&gt;iwd&lt;/code&gt; 默认使用的是系统的DHCP和DNS服务器，所以&lt;strong&gt;你还需要启动&lt;code&gt;systemd-networkd.service&lt;/code&gt;和&lt;code&gt;systemd-resolved.service&lt;/code&gt;才行，因为新系统默认不会自启动这两个服务，需要你手动开启&lt;/strong&gt;。当然，你也可以使用&lt;code&gt;iwd&lt;/code&gt;内置的DHCP服务器，开启方法可以参考我之前写的一篇&lt;a href=&quot;./iwd-tutorial&quot;&gt;文章&lt;/a&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;到这里你才能正常使用&lt;code&gt;iwd&lt;/code&gt;这个工具，具体使用方法可以参考前文&lt;a href=&quot;#%E7%BD%91%E7%BB%9C%E8%AE%BE%E7%BD%AE&quot;&gt;网络设置&lt;/a&gt;部分&lt;/p&gt;
&lt;h3&gt;安装显示服务器&lt;/h3&gt;
&lt;p&gt;因为个人比较喜欢 i3，所以我安装的是 xorg，你也可以选择新的显示协议&lt;code&gt;wayland&lt;/code&gt;。
使用下面的命令安装开源的 &lt;code&gt;xorg&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 安装所有xorg相关包
sudo pacman -S xorg

# 以下命令可以只安装必要的xorg包，可以避免不必要的包的安装，
sudo pacman -S xorg-server
# 但是有些可能其他功能需要的包会缺失，导致功能不完善
# 所以如果你不太理解这其中的关系，建议除了xorg-server之外，也安装xorg-apps包组
sudo pacman -S xorg-server xorg-apps
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;安装显卡驱动&lt;/h3&gt;
&lt;p&gt;我的机器使用的是ASUS的AMD显卡&lt;code&gt;6700XT-TUF&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;对于 AMD 显卡，安装开源的amdgpu驱动：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo pacman -S xf86-video-amdgpu
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;p.s. AMD的显卡驱动有点问题，会导致系统不稳定黑屏/卡死/卡顿等问题，所以可能需要一些额外的配置，这部分我会单独写出来&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;对于 NVIDIA 显卡，安装开源驱动&lt;code&gt;nouveau&lt;/code&gt;即可：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo pacman -S mesa xf86-video-nouveau
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;安装桌面环境&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;前面说了，我比较喜欢 i3，所以我通常不会安装类似gnome，kde这种集成的桌面环境。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;安装窗口管理器&lt;/h3&gt;
&lt;p&gt;安装 &lt;code&gt;i3-wm&lt;/code&gt; 包组：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo pacman -S i3-wm
# 推荐安装i3lock，可以很方便的集成锁屏功能
sudo pacman -S i3lock
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;TODO：配置&lt;/p&gt;
&lt;h3&gt;安装显示管理器&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;[!WARNING]&lt;/p&gt;
&lt;p&gt;如果使用wayland协议的管理器，推荐安装&lt;code&gt;sddm&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;由于只安装了一个窗口管理器i3，并不包含显示管理器(DM)，所以还需要自己选择一个 DM 进行安装，我选择的是&lt;code&gt;lightdm&lt;/code&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;安装lightdm和greeter：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;sudo pacman -S lightdm
# 安装默认的greeter
sudo pacman -S lightdm-gtk-greeter
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;设置为开机自启动：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;systemctl enable lightdm.service
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;[!TIP]
如果你安装的不是&lt;code&gt;lightdm-gtk-greeter&lt;/code&gt;，还需要额外的配置，编辑&lt;code&gt;/etc/lightdm/lightdm.conf&lt;/code&gt;设置默认的 greeter：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[Seat:*]
...
greeter-session=&amp;lt;lightdm-greeter-name&amp;gt;
...
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;h2&gt;个性化系统&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;[!TIP]
如果你使用的是i3，第一次登录进入gui之后，会提示你初始化一个配置，选择mod键（一路回车mod是win键）。打开命令行的默认快捷键是&lt;code&gt;$mod + return&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;快捷键/自启动的配置都是基于&lt;code&gt;i3&lt;/code&gt;的配置。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;安装AUR助手&lt;/h3&gt;
&lt;p&gt;因为有一些软件包并没有收录进官方的仓库里，所以为了安装方便，最好安装一个AUR助手，推荐&lt;code&gt;paru&lt;/code&gt;，rust语言写的，用起来很方便，性能也很好。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#首先安装一些构建软件必需的包
sudo pacman -S --needed base-devel
git clone https://aur.archlinux.org/paru.git
cd paru
makepkg -si
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;之后，就可以使用&lt;code&gt;paru&lt;/code&gt;来安装一些非官方的包了，命令行参数和官方的&lt;code&gt;pacman&lt;/code&gt;基本一致。&lt;/p&gt;
&lt;h3&gt;安装中文输入法&lt;/h3&gt;
&lt;p&gt;archlinux 中文输入法框架有&lt;code&gt;fcitx&lt;/code&gt;/&lt;code&gt;ibus&lt;/code&gt;/&lt;code&gt;fcitx5&lt;/code&gt;，其中&lt;code&gt;fcitx5&lt;/code&gt;貌似是刚刚出现的，之前没见过，所以我就试了试，安装配置起来还挺简单的：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;安装&lt;code&gt;fcitx5&lt;/code&gt;软件包&lt;/li&gt;
&lt;li&gt;创建&lt;code&gt;~/.pam_environment&lt;/code&gt;并配置环境变量：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;GTK_IM_MODULE DEFAULT=fcitx
QT_IM_MODULE DEFAULT=fcitx
XMODIFIERS DEFAULT=@im=fcitx
SDL_IM_MODULE=fcitx
GLFW_IM_MODULE=ibus
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;安装中文输入法引擎&lt;code&gt;fcitx5-rime&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo pacman -S fcitx5-rime
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;安装&lt;a href=&quot;https://github.com/iDvel/rime-ice&quot;&gt;雾凇拼音&lt;/a&gt;词库（optional），该词库并没有在官方仓库，需要在AUR仓库安装：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;paru -S rime-ice-git
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;安装浏览器&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;sudo pacman -S firefox
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;note: 安装Firefox浏览器的时候会让你选择一种字体以及jack音频连接套件，我选择的是&lt;code&gt;ttf-dejavu&lt;/code&gt;和&lt;code&gt;pipewire-jack&lt;/code&gt;（选这个是因为我的音频配置是基于&lt;code&gt;pipewire&lt;/code&gt;的）。&lt;/p&gt;
&lt;h3&gt;安装Terminal&lt;/h3&gt;
&lt;p&gt;i3默认的是&lt;code&gt;xterm&lt;/code&gt;，功能简单，外观一般，推荐&lt;code&gt;alacritty&lt;/code&gt;或者&lt;code&gt;kitty&lt;/code&gt;，还有一个&lt;code&gt;wezterm&lt;/code&gt;，和&lt;code&gt;alacirtty&lt;/code&gt;一样都是rust的，性能方面没的说，配置用的lua，不过我用习惯了&lt;code&gt;alacritty&lt;/code&gt;懒得换了。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo pacman -S alacritty
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;安装字体&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;# 英文字体
sudo pacman -S ttf-dejavu ttf-ibm-plex ttf-roboto ttf-fira-code ttf-fira-sans
# 中文字体
sudo pacman -S noto-fonts-cjk
# 表情符号
sudo pacman -S noto-fonts-emoji ttf-joypixels

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;编程字体&lt;/strong&gt;推荐：
手动安装，在&lt;a href=&quot;https://www.nerdfonts.com/&quot;&gt;这个网站里&lt;/a&gt;选择自己喜欢的&lt;code&gt;nerdfonts&lt;/code&gt;下载下来，放入&lt;code&gt;~/.local/share/fonts/&lt;/code&gt;目录下，个人比较喜欢&lt;code&gt;FiraCode&lt;/code&gt;，&lt;code&gt;Hack&lt;/code&gt;，&lt;code&gt;Jetbrains&lt;/code&gt;系列。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Vercel&lt;/code&gt;新开源的字体也很不错，推荐使用，在&lt;a href=&quot;https://vercel.com/font&quot;&gt;这里&lt;/a&gt;下载。&lt;/p&gt;
&lt;h3&gt;安装 zsh&lt;/h3&gt;
&lt;p&gt;安装一个好看而且功能强大的 shell 很有必要，比如说 zsh。配置 zsh 的话，我推荐使用&lt;a href=&quot;https://github.com/ohmyzsh/ohmyzsh&quot;&gt;oh my zsh&lt;/a&gt;这个框架个性化 zsh，配置 zsh 起来简单方便。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;安装 zsh&lt;/li&gt;
&lt;li&gt;使用 curl 安装 ohmyzsh，这个脚本还可以帮你自动更改默认的 shell&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;p.s. 手动更换默认 shell 的方法：&lt;code&gt;sudo chsh -s /usr/bin/zsh &amp;lt;username&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;自定义配置 zsh，推荐使用&lt;code&gt;Oh My Zsh&lt;/code&gt;框架，简单易上手，具体可以参考 ohmyzsh 的&lt;a href=&quot;https://github.com/ohmyzsh/ohmyzsh/wiki&quot;&gt;官方 wiki&lt;/a&gt;。&lt;/p&gt;
&lt;h3&gt;安装文件管理器&lt;/h3&gt;
&lt;p&gt;我个人比较喜欢&lt;code&gt;thunar&lt;/code&gt;（XFCE的内置文件管理器，很轻便，功能也很强大，支持分屏，&lt;code&gt;F3&lt;/code&gt;是分屏快捷键）。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo pacman -S thunar
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;配置相关特性&lt;/h4&gt;
&lt;p&gt;thunar还有两个推荐安装的feature插件&lt;code&gt;thunar-archive-plugin&lt;/code&gt;和&lt;code&gt;thunar-volman&lt;/code&gt;，分别用来处理压缩包和硬盘分区。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo pacman -S thunar-archive-plugin thunar-volman
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;安装压缩插件还需要一些压缩/解压缩工具：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo pacman -S zip p7zip unzip
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;推荐安装一个图形化压缩工具，用来文件管理器的右键菜单，推荐&lt;code&gt;xarchiver&lt;/code&gt;，gnome的&lt;code&gt;file-roller&lt;/code&gt;，二选一即可：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo pacman -S xarchiver file-roller
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;&lt;/h3&gt;
&lt;p&gt;自动检测及挂载设备功能：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo pacman -S gvfs
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;缩略图功能：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo pacman -S tumbler
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;程序启动器 rofi&lt;/h3&gt;
&lt;p&gt;相比于&lt;code&gt;i3&lt;/code&gt;默认的&lt;code&gt;dmenu&lt;/code&gt;，更美观的程序启动器，高度自定义&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo pacman -S rofi
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;修改&lt;code&gt;i3&lt;/code&gt;配置文件，添加快捷键：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;bindsym $mod+d exec rofi -show drun
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;状态栏 polybar&lt;/h3&gt;
&lt;p&gt;窗口状态栏，比i3内置的功能更强大，自定义化程度超高。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo pacman -S polybar
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;加入 &lt;code&gt;i3&lt;/code&gt; 自启动&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;exec_always --no-startup-id polybar barname
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;复制示例模板：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo cp /etc/polybar/config.ini ~/.config/polybar/config.ini
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后基于模板自定义，具体可以参考官方&lt;a href=&quot;https://github.com/polybar/polybar/wiki&quot;&gt; &lt;code&gt;wiki&lt;/code&gt; &lt;/a&gt;页面。&lt;/p&gt;
&lt;h3&gt;安装截图工具&lt;/h3&gt;
&lt;p&gt;推荐&lt;code&gt;flameshot&lt;/code&gt;，操作简单且功能强大。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo pacman -S flameshot
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;配置快捷键：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;bindsym $mod+Shift+x exec flameshot gui
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;默认显示系统托盘图标（与polybar无痛衔接）&lt;/p&gt;
&lt;h3&gt;配置音频&lt;/h3&gt;
&lt;p&gt;使用&lt;code&gt;pipewire&lt;/code&gt;框架，安装相关包：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo pacman -S pipewire pipewire-audio pipewire-pulse pipewire-alsa pipewire-jack
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中蓝牙相关的功能在&lt;code&gt;pipewire-audio&lt;/code&gt;中。&lt;/p&gt;
&lt;p&gt;会话管理器和GUI工具:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo pacman -S wireplumer helvum
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;pulse音频管理器：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo pacman -S pavucontrol
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;系统主题&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;WhiteSur&lt;/code&gt;系列主题，包含鼠标/图标/GTK主题。&lt;/p&gt;
&lt;p&gt;可以在GitHub下载/freedesktop.org下载&lt;/p&gt;
&lt;p&gt;手动下载并放入对应路径下：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;主题&lt;/th&gt;
&lt;th&gt;路径&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;鼠标&lt;/td&gt;
&lt;td&gt;&lt;code&gt;~/.icons&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;GTK&lt;/td&gt;
&lt;td&gt;&lt;code&gt;~/.themes&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;图标&lt;/td&gt;
&lt;td&gt;&lt;code&gt;~/.icons&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
</content:encoded></item><item><title>如何将Julia添加到Jupyter Notebook</title><link>https://smj.im/blag/posts/integrate-julia-into-jupyter-notebook/</link><guid isPermaLink="true">https://smj.im/blag/posts/integrate-julia-into-jupyter-notebook/</guid><description>我在学习Julia语言的时候，配置Jupyter开发环境的过程。</description><pubDate>Mon, 29 Jun 2020 01:26:11 GMT</pubDate><content:encoded>&lt;blockquote&gt;
&lt;p&gt;Julia 是一门灵活的动态语言,适合用于科学计算和数值计算,并且性能可与传统的静态类型语言媲美。JupyterNotebook 是目前最流行的数据科学 Web 程序，功能涵盖数据清理和转换，数值模拟，统计建模，数据可视化，机器学习等。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本文使用 IJulia 将 Julia 集成到 Jupyter 交互式环境中。假设你已经安装好了 Julia 和 Jupyter 环境。&lt;/p&gt;
&lt;h2&gt;第一步&lt;/h2&gt;
&lt;p&gt;在命令行键入 julia，运行 Julia 程序，出现以下提示:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ julia
   _       _ _(_)_     |  Documentation: https://docs.julialang.org
  (_)     | (_) (_)    |
   _ _   _| |_  __ _   |  Type &quot;?&quot; for help, &quot;]?&quot; for Pkg help.
  | | | | | | |/ _` |  |
  | | |_| | | | (_| |  |  Version 1.4.2 (2020-05-23)
 _/ |\__&apos;_|_|_|\__&apos;_|  |  Official https://julialang.org/ release
|__/                   |

julia&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;第二步&lt;/h2&gt;
&lt;p&gt;在提示符 julia&amp;gt;后键入以下内容安装&lt;strong&gt;IJulia&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;using Pkg
Pkg.add(&quot;IJulia&quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;第三步&lt;/h2&gt;
&lt;p&gt;安装完成后，在提示符中键入以下内容启动带有 Julia 环境的 Jupyter Notebook：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;using IJulia
notebook()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;p.s.&lt;/em&gt; 如果你想使用最新的 Jupyter Lab，可以使用 jupyterlab()命令替换上面的 notebook()命令。&lt;/p&gt;
&lt;h2&gt;第四步&lt;/h2&gt;
&lt;p&gt;上面的 notebook()命令会启动 Jupyter Notebook，然后点击 New 选择 New 文件的类型为 Julia 1.4.2，即可编写 julia 代码：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pichost.netlify.app/blog/65603810b13cf.webp&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;p&gt;例如，使用 println 函数打印 hello, julia!：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pichost.netlify.app/blog/65603a5b879ce.webp&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
</content:encoded></item><item><title>费曼技巧：最好的学习方式</title><link>https://smj.im/blag/posts/feynman-technique/</link><guid isPermaLink="true">https://smj.im/blag/posts/feynman-technique/</guid><pubDate>Wed, 24 Jun 2020 02:12:13 GMT</pubDate><content:encoded>&lt;h2&gt;写在前面&lt;/h2&gt;
&lt;p&gt;最近读书的时候偶然发现了费曼技巧，所以查阅了一些资料，找到了这篇文章，写的还不错，就翻译了一下给大家看看，原文在&lt;a href=&quot;https://fs.blog/2012/04/feynman-technique/&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;其实费曼技巧原理很简单，当时了解到的时候，就感觉有点像我给自己的父母去解释一些新的概念的时候的思路：用简单的语言去解释一些较为复杂的概念，在这个思路的转换期间，你也就学会了这个概念。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;em&gt;如果你正在寻找一种方法来增强你的学习并变得更聪明，那么费曼技术可能就是绝对学习任何东西的最佳方法。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;**费曼技巧(Feynman Technique)**有四个步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;选择想学习的概念&lt;/li&gt;
&lt;li&gt;假装正在将其教给小孩子&lt;/li&gt;
&lt;li&gt;找出解释中的空白(gaps,自己不理解的部分)；回到原始资料，以更好地理解它。&lt;/li&gt;
&lt;li&gt;查看并简化（可选）&lt;/li&gt;
&lt;/ol&gt;
&lt;hr /&gt;
&lt;p&gt;如果你不学习，就表示停滞不前。但是，我们如何获得关于所学知识的反馈？以及我们如何去学习新的学科并找出我们现有知识中的空白？&lt;/p&gt;
&lt;h2&gt;两种知识&lt;/h2&gt;
&lt;p&gt;费曼了解&lt;a href=&quot;https://fs.blog/2015/01/richard-feynman-knowing-something/&quot;&gt;了解某事和知道某事的名字之间的区别&lt;/a&gt;，这是他成功的最重要原因之一。我们大多数人专注于&lt;a href=&quot;https://fs.blog/2015/09/two-types-of-knowledge/&quot;&gt;错误的知识类型&lt;/a&gt;。第一种知识集中在知道事物的名称，即所谓的事物名称。第二种知识重点是实际了解一些东西，即了解一些东西。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“说自己知道自己的想法但无法表达的人通常不知道自己的想法。” —莫蒂默·阿德勒&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;费曼技巧&lt;/h2&gt;
&lt;h3&gt;第一步：教给孩子(Teach it to a child)&lt;/h3&gt;
&lt;p&gt;取出一张空白的纸。在顶部写下你要学习的主题。现在，把你要了解的所有知识写出来，就像在教给孩子一样。不是你的聪明成人朋友，而是 12 岁的孩子，而且他的词汇量和注意力跨度足以理解基本概念和关系。&lt;/p&gt;
&lt;p&gt;事实证明，我们欺骗自己的方法之一就是我们使用了复杂的词汇和行话，以掩盖我们缺乏理解的事实。&lt;/p&gt;
&lt;p&gt;当你以一种可以让孩子理解的简单语言从头到尾写下一个想法时，你会强迫自己更深入地理解该概念，并简化这些想法之间的关系和联系。其中一些可能很容易理解。在这些地方你可以清楚地了解该主题。在其他时候，你会很挣扎。这些是你在理解上有一些空白的地方。&lt;/p&gt;
&lt;h3&gt;第二步：检查(Review)&lt;/h3&gt;
&lt;p&gt;只有当你遇到知识上的空白时，即你忘记了重要的东西，无法解释它，或者只是在思考一些因素如何相互作用时，才能真正开始学习。&lt;/p&gt;
&lt;p&gt;既然你已经知道自己陷于何处，那就回到原始资料重新学习它，直到可以用基本术语进行解释。当你可以不加专业术语地阐述自己的理解时，就可以表明自己真正理解它了。这是学习新知识所必需要的努力，如果你跳过这一步会导致“已经理解了“的错觉。&lt;/p&gt;
&lt;p&gt;确定自身的理解范围还可以限制您可能犯的错误，并增加应用知识时获得成功的机会。&lt;/p&gt;
&lt;h3&gt;第三步：组织和简化(Organize and Simplify)&lt;/h3&gt;
&lt;p&gt;现在，你有了一组手工制作的笔记。检查它们，以确保你没有错误地从原始资料中借用任何专业术语。将它们整理成一个简单的解释，你可以说出来给自己听。如果阐述的不简单或听起来令人困惑，则表明你对该领域的理解仍需要一些努力。&lt;/p&gt;
&lt;p&gt;如果你一遍又一遍地遵循这种方法去学习新的知识，最终将得到一个装订满各种主题页的活页夹。如果你每年花费一些时间整理这种活页夹，你会发现你已经学会了很多东西。&lt;/p&gt;
&lt;h3&gt;第四步：可选：传播(Transmit)&lt;/h3&gt;
&lt;p&gt;如果你真的想确定自己的理解力，那就把它说给某个人听（最好是对这门学科了解甚少的人，或者找到那个 12 岁的孩子！）。对你掌握的知识的最终考验是你将知识传达给他人的能力。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;em&gt;费曼技巧&lt;/em&gt;不仅是学习的绝妙方法，而且还是进入不同思维方式的窗口，可让你将想法分解并从头开始进行重构。你不仅可以加强自己的学习，而且还可以加强他们的学习。重要的是，以这种方式处理问题可以使你了解那些不知道他们自己在说什么的人。（请参阅&lt;a href=&quot;https://fs.blog/2016/12/batesian-mimicry/&quot;&gt;贝茨模拟&lt;/a&gt;）Feynman 的方法直观地认为，智力是成长的过程，与 Carol Dweck 的著作很好地吻合，后者很好地描述了&lt;a href=&quot;https://fs.blog/2015/03/carol-dweck-mindset/&quot;&gt;固定和成长心态之间的差异&lt;/a&gt;。&lt;/p&gt;
</content:encoded></item><item><title>How to Create Linux Desktop Entry</title><link>https://smj.im/blag/posts/how-to-create-linux-desktop-entry/</link><guid isPermaLink="true">https://smj.im/blag/posts/how-to-create-linux-desktop-entry/</guid><pubDate>Fri, 13 Mar 2020 13:34:52 GMT</pubDate><content:encoded>&lt;ol&gt;
&lt;li&gt;create a file named &lt;code&gt;yourappname.desktop&lt;/code&gt; in &lt;code&gt;/usr/share/applications/&lt;/code&gt; directory or &lt;code&gt;~/.local/share/applications/&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;input the following lines:&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;[Desktop Entry]
Type=Application
Terminal=false
Exec=/path/to/app
Name=app
Comment=app comment
Icon=/path/to/app/icon
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>Make a TODO robot with Github Actions</title><link>https://smj.im/blag/posts/make-a-todo-bot-with-github-actions/</link><guid isPermaLink="true">https://smj.im/blag/posts/make-a-todo-bot-with-github-actions/</guid><description>Create a todolist robot with daily email notification</description><pubDate>Fri, 03 Jan 2020 10:35:00 GMT</pubDate><content:encoded>&lt;h2&gt;What&apos;s Github Actions&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/features/actions&quot;&gt;Github Actions&lt;/a&gt; is a &lt;strong&gt;CI&lt;/strong&gt;(continuous integration) and &lt;strong&gt;CD&lt;/strong&gt;(continuous deployment) service that help you automate your software development workflows in the same place you store code and collaborate on pull requests and issues. It was launched in October 2018 and was officially available to all users in November 2019. With Github Actions you can write individual tasks, called &lt;em&gt;actions&lt;/em&gt;, and combine them to create a custom workflow. &lt;em&gt;Workflows&lt;/em&gt; are custom automated processes that you can set up in your repository to build, test, package, release, or deploy any code project on GitHub.&lt;/p&gt;
&lt;p&gt;You can create workflows using actions defined in your repository, open source actions in a public repository on GitHub, or a published Docker container image. But &lt;em&gt;workflows in forked repositories don&apos;t run by default.&lt;/em&gt; If you don&apos;t want to create your actions by yourself, you can discover actions in the &lt;a href=&quot;https://github.com/marketplace?type=actions&quot;&gt;GitHub Marketplace&lt;/a&gt;, also you can share your actions with the Marketplace.&lt;/p&gt;
&lt;p&gt;Ok, now let&apos;s go.&lt;/p&gt;
&lt;h2&gt;Getting started&lt;/h2&gt;
&lt;p&gt;We can get this &lt;em&gt;Send Mail&lt;/em&gt; Actions from &lt;a href=&quot;https://github.com/marketplace/actions/send-email&quot;&gt;here&lt;/a&gt; or &lt;a href=&quot;https://github.com/dawidd6/action-send-mail&quot;&gt;source&lt;/a&gt;. It help us send email to our inbox.&lt;/p&gt;
&lt;h2&gt;Configuring Github Actions&lt;/h2&gt;
&lt;p&gt;We should create a directory named &lt;code&gt;.github/workflows&lt;/code&gt; to store our workflow files at the root of our repository. In &lt;code&gt;.github/workflows&lt;/code&gt;, add a &lt;code&gt;.yml&lt;/code&gt; or &lt;code&gt;.yaml&lt;/code&gt; file for our workflow. For example, &lt;code&gt;.github/workflows/auto.yml&lt;/code&gt;.&lt;/p&gt;
&lt;h3&gt;First we set a trigger&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;name: GitHub Actions Email Bot

on:
schedule:
  - cron: &apos;0 22 * * *&apos;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In the above code, &lt;code&gt;name&lt;/code&gt; is actions description, &lt;code&gt;on&lt;/code&gt; is the trigger condition. We use the POSIX cron syntax to schedule the workflow. It is triggered at 6:00am(UTC+8) everyday.&lt;/p&gt;
&lt;h3&gt;Next writing a TODO list and converting it from markdown to html&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;runs-on: ubuntu-latest
steps:
  - name: Checkout
    uses: actions/checkout@v2.0.0
  - name: Get pandoc
    run: sudo apt-get install pandoc
  - name: Convert My TODO List
    run: pandoc ./TODO.md &amp;gt; todo.html
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Last configuring the send email actions&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;- name: Send email
  uses: dawidd6/action-send-mail@v1.3.0
  with:
    server_address: smtp.gmail.com
    server_port: 465
    username: ${{ secrets.MAIL_USERNAME }}
    password: ${{ secrets.MAIL_PASSWORD }}
    subject: My TODO List
    body: file://todo.html
    to: test@example.com
    from: TODO List Notification
    content_type: text/html
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;For security, we should set our email &lt;code&gt;username&lt;/code&gt; and &lt;code&gt;password&lt;/code&gt; in the &lt;code&gt;settings/secrets&lt;/code&gt; menu of the project. I set my email username like &lt;code&gt;MAIL_USERNAME&lt;/code&gt;, password like &lt;code&gt;MAIL_PASSWORD&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Now we can receive a TODO list email every morning.&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;This is my full &lt;code&gt;todo.yaml&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;name: GitHub Actions Email Bot

on:
  schedule:
    - cron: &apos;0 22 * * *&apos;

jobs:
  Todo_bot:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v2.0.0
      - name: Get pandoc
        run: sudo apt-get install pandoc
      - name: Get My TODO List
        run: pandoc ./TODO.md &amp;gt; result.html
      - name: Send email
        uses: dawidd6/action-send-mail@v1.3.0
        with:
          server_address: smtp.gmail.com
          server_port: 465
          username: ${{ secrets.MAIL_USERNAME }}
          password: ${{ secrets.MAIL_PASSWORD }}
          subject: TODO List
          body: file://result.html
          to: test@example.com
          from: TODO List Notification
          content_type: text/html
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>C++继承 多态 虚函数</title><link>https://smj.im/blag/posts/cpp-oop-concepts/</link><guid isPermaLink="true">https://smj.im/blag/posts/cpp-oop-concepts/</guid><pubDate>Sun, 29 Dec 2019 02:02:05 GMT</pubDate><content:encoded>&lt;h2&gt;继承&lt;/h2&gt;
&lt;h3&gt;访问控制和继承&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;访问&lt;/th&gt;
&lt;th&gt;public&lt;/th&gt;
&lt;th&gt;protected&lt;/th&gt;
&lt;th&gt;private&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;同一个类&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;派生类&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;td&gt;no&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;外部的类&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;td&gt;no&lt;/td&gt;
&lt;td&gt;no&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;一个派生类继承了所有的基类方法，但下列情况除外：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基类的构造函数、析构函数和拷贝构造函数。&lt;/li&gt;
&lt;li&gt;基类的重载运算符。&lt;/li&gt;
&lt;li&gt;基类的友元函数。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;一个问题&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;class A{
private:
    int a;
    char b;
};

class B: public A{
public:
    char getc(){return this-&amp;gt;c;}
private:
    char c=&apos;j&apos;;
};

int main() {
    B test;
    cout&amp;lt;&amp;lt;test.getc()&amp;lt;&amp;lt;endl;
    cout&amp;lt;&amp;lt;sizeof(int)&amp;lt;&amp;lt;endl;
    // output is 4
    cout&amp;lt;&amp;lt;sizeof(char)&amp;lt;&amp;lt;endl;
    // output is 1
    cout&amp;lt;&amp;lt;sizeof(test)&amp;lt;&amp;lt;endl;
    // output is 8
}
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;如果把 A 的 private 属性 a,b 变成 public 属性，那么 test 的 size 就变成了 12&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;继承类型&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;公有继承（public）：&lt;strong&gt;当一个类派生自&lt;/strong&gt;公有&lt;/strong&gt;基类时，基类的&lt;strong&gt;公有&lt;/strong&gt;成员也是派生类的&lt;strong&gt;公有&lt;/strong&gt;成员，基类的&lt;strong&gt;保护&lt;/strong&gt;成员也是派生类的&lt;strong&gt;保护&lt;/strong&gt;成员，基类的&lt;strong&gt;私有&lt;/strong&gt;成员不能直接被派生类访问，但是可以通过调用基类的&lt;strong&gt;公有&lt;/strong&gt;和&lt;strong&gt;保护&lt;/strong&gt;成员来访问。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;保护继承（protected）：&lt;/strong&gt; 当一个类派生自&lt;strong&gt;保护&lt;/strong&gt;基类时，基类的&lt;strong&gt;公有&lt;/strong&gt;和&lt;strong&gt;保护&lt;/strong&gt;成员将成为派生类的&lt;strong&gt;保护&lt;/strong&gt;成员。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;私有继承（private）：&lt;strong&gt;当一个类派生自&lt;/strong&gt;私有&lt;/strong&gt;基类时，基类的&lt;strong&gt;公有&lt;/strong&gt;和&lt;strong&gt;保护&lt;/strong&gt;成员将成为派生类的&lt;strong&gt;私有&lt;/strong&gt;成员。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在多继承时，如果省略继承方式，默认为 private&lt;/p&gt;
&lt;h2&gt;多态&lt;/h2&gt;
&lt;p&gt;C++多态性是通过虚函数来实现的&lt;/p&gt;
&lt;p&gt;多态与非多态的实质区别就是函数地址是早绑定还是晚绑定。如果函数的调用，在编译器编译期间就可以确定函数的调用地址，并生产代码，是静态的，就是说地址是早绑定的。而如果函数调用的地址不能在编译器期间确定，需要在运行时才确定，这就属于晚绑定。&lt;/p&gt;
&lt;h3&gt;多态的四种形式&lt;/h3&gt;
&lt;p&gt;多态总体上分为：编译时的多态（静态多态）和运行时的多态（动态多态）。又被细分为：&lt;strong&gt;参数多态&lt;/strong&gt;，&lt;strong&gt;包含多态&lt;/strong&gt;，&lt;strong&gt;过载多态&lt;/strong&gt;，&lt;strong&gt;强制多态&lt;/strong&gt;。前两种为通用多态，后两种为特定多态。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;参数多态：采用参数化模板，通过给出不同的类型参数，使得一个结构有多种类型。如 C++语言中的函数模板和类模板属于参数多态。参数多态又叫静态多态，它的执行速度快，异常少，调用在编译时已经确定。参数多态是应用比较广泛的一种多态，被称为最纯的多态。&lt;/li&gt;
&lt;li&gt;包含多态：在许多语言中都存在，最常见的例子就是子类型化，即一个类型是另外一个类型的子类型。一般需要进行运行时的类型检查，属于动态多态。包含多态的基础是虚函数。虚函数是引入了派生概念后用来表现基类和派生类的成员函数之间的一种关系。&lt;/li&gt;
&lt;li&gt;过载多态：同一个名字在不同的上下文中所代表的含义不同。典型的例子是运算符重载和函数重载，属于静态多态。&lt;/li&gt;
&lt;li&gt;强制多态：编译程序通过语义操作，把操作对象的类型强行加以变换，以符合函数或操作符的要求。程序设计语言中基本类型的大多数操作符，在发生不同类型的数据进行混合运算时，编译程序一般都会进行强制多态。程序员也可以显示地进行强制多态的操作。如 &lt;code&gt;int+double&lt;/code&gt;，编译系统一般会把 int 转换为 double，然后执行 double+double 运算，这个 &lt;code&gt;int-&amp;gt;double&lt;/code&gt; 的转换，就实现了强制多态，即可是隐式的，也可显式转换。强制多态属于静态多态。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;相关概念&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;多态性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;指相同对象收到不同消息或不同对象收到相同消息时产生不同的实现动作。C++支持两种多态性：编译时多态性，运行时多态性。&lt;strong&gt;a、编译时多态性：通过重载函数实现 b、运行时多态性：通过虚函数实现&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/Hackbuteer1/article/details/7475622&quot;&gt;https://blog.csdn.net/Hackbuteer1/article/details/7475622&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;虚函数&lt;/h2&gt;
&lt;h3&gt;定义&lt;/h3&gt;
&lt;p&gt;C++中的虚函数的作用主要是实现了多态的机制。基类定义虚函数，子类可以重写该函数；在派生类中对基类定义的虚函数进行重写时，需要再派生类中声明该方法为虚方法。&lt;/p&gt;
&lt;p&gt;在派生类中重新定义基类中定义的虚函数时，会告诉编译器不要静态链接（又称早绑定：基类定义的函数没有使用 virtual 关键字，调用的函数被编译器设置为基类中的版本）到该函数。我们想要的是在程序中任意点可以根据所调用的对象类型来选择调用的函数，这种操作被称为&lt;strong&gt;动态链接&lt;/strong&gt;，或&lt;strong&gt;后期绑定&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;虚函数只能借助于指针或者引用来达到多态的效果。&lt;/p&gt;
&lt;p&gt;当子类重新定义了父类的虚函数后，当父类的指针指向子类对象的地址时，[即 B b; A a = b;] 父类指针根据赋给它的不同子类指针，动态的调用子类的该函数，而不是父类的函数（不使用 virtual 方法，如果使用了&lt;strong&gt;virtual&lt;/strong&gt;关键字，程序将根据&lt;strong&gt;引用或指针&lt;/strong&gt;指向的 &lt;strong&gt;对象类型&lt;/strong&gt;来选择方法，否则使用&lt;strong&gt;引用类型或指针类型&lt;/strong&gt;来选择方法。），且这样的函数调用发生在运行阶段，而不是发生在编译阶段，称为&lt;strong&gt;动态联编&lt;/strong&gt;。&lt;/p&gt;
&lt;h3&gt;实例&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;class A
{
public:
    void fee()
    {
        cout&amp;lt;&amp;lt;&quot;Parent&quot;&amp;lt;&amp;lt;endl;
    }
    virtual void foo()
    {
        cout&amp;lt;&amp;lt;&quot;A::foo() is called&quot;&amp;lt;&amp;lt;endl;
    }
};
class B:public A
{
public:
    void fee()
    {
        cout&amp;lt;&amp;lt;&quot;Child&quot;&amp;lt;&amp;lt;endl;
    }
    virtual void foo()
    {
        cout&amp;lt;&amp;lt;&quot;B::foo() is called&quot;&amp;lt;&amp;lt;endl;
    }
};

int main(void)
{
    A *a = new B();
    a-&amp;gt;fee();   // 输出为：Parent
    a-&amp;gt;foo();   // 输出为：B::foo() is called
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;虚函数底层实现机制&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;实现原理：虚函数表+虚表指针&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;编译器处理虚函数的方法是：&lt;/p&gt;
&lt;p&gt;为每个类对象添加一个隐藏成员，隐藏成员中保存了一个指向函数地址数组的指针，称为虚表指针（vptr），这种数组成为虚函数表（virtual function table, vtbl），即，&lt;strong&gt;每个类使用一个虚函数表，每个类对象用一个虚表指针&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;基类对象包含一个虚表指针，指向基类中所有虚函数的地址表。派生类对象也将包含一个虚表指针，指向派生类虚函数表。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果派生类重写了基类的虚方法，该派生类虚函数表将保存重写的虚函数的地址，而不是基类的虚函数地址。&lt;/li&gt;
&lt;li&gt;如果基类中的虚方法没有在派生类中重写，那么派生类将继承基类中的虚方法，而且派生类中虚函数表将保存基类中未被重写的虚函数的地址。注意，如果派生类中定义了新的虚方法，则该虚函数的地址也将被添加到派生类虚函数表中。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://pichost.netlify.app/blog/65603a6571e8a.webp&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class A {
public:
    virtual void vfunc1();
    virtual void vfunc2();
    void func1();
    void func2();
private:
    int m_data1, m_data2;
};

class B : public A {
public:
    virtual void vfunc1();
    void func1();
private:
    int m_data3;
};

class C: public B {
public:
    virtual void vfunc2();
    void func2();
private:
    int m_data1, m_data4;
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;类 A 是基类，类 B 继承类 A，类 C 又继承类 B：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pichost.netlify.app/blog/6560381a290ad.webp&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;纯虚函数&lt;/h2&gt;
&lt;h3&gt;定义&lt;/h3&gt;
&lt;p&gt;纯虚函数是在基类中声明的虚函数，它在基类中没有定义，但要求任何派生类都要定义自己的实现方法。在基类中实现纯虚函数的方法是在函数原型后加“=0”：&lt;code&gt;virtual void funtion1()=0&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;声明了纯虚函数的类是一个抽象类。所以，用户不能创建类的实例，只能创建它的派生类的实例。派生类仅仅只是继承函数的接口，必须实现函数才能使用。&lt;/p&gt;
&lt;h3&gt;抽象类&lt;/h3&gt;
&lt;p&gt;抽象类是一种特殊的类，它是为了抽象和设计的目的为建立的，它处于继承层次结构的较上层。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;抽象类的定义：称带有纯虚函数的类为抽象类。&lt;/li&gt;
&lt;li&gt;抽象类的作用：抽象类的主要作用是将有关的操作作为结果接口组织在一个继承层次结构中，由它来为派生类提供一个公共的根，派生类将具体实现在其基类中作为接口的操作。所以抽象类实际上刻画了一组子类的操作接口的通用语义，这些语义也传给子类，子类可以具体实现这些语义，也可以再将这些语义传给自己的子类。&lt;/li&gt;
&lt;li&gt;使用抽象类时注意：&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;抽象类只能作为基类来使用，其纯虚函数的实现由派生类给出。如果派生类中没有重新定义纯虚函数，而只是继承基类的纯虚函数，则这个派生类仍然还是一个抽象类。如果派生类中给出了基类纯虚函数的实现，则该派生类就不再是抽象类了，它是一个可以建立对象的具体的类。&lt;/li&gt;
&lt;li&gt;抽象类是不能定义对象的。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;在有动态分配堆上内存的时候，析构函数必须是虚函数，但没有必要是纯虚的。友元不是成员函数，只有成员函数才可以是虚拟的，因此友元不能是虚拟函数。但可以通过让友元函数调用虚拟成员函数来解决友元的虚拟问题。&lt;/p&gt;
&lt;p&gt;析构函数应当是虚函数，将调用相应对象类型的析构函数，因此，如果指针指向的是子类对象，将调用子类的析构函数，然后自动调用基类的析构函数。&lt;/p&gt;
&lt;h2&gt;Reference&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/Hackbuteer1/article/details/7558868&quot;&gt;https://blog.csdn.net/Hackbuteer1/article/details/7558868&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/iFuMI/article/details/51088091&quot;&gt;https://blog.csdn.net/iFuMI/article/details/51088091&lt;/a&gt;&lt;/p&gt;
</content:encoded></item><item><title>C++ inline关键字详解</title><link>https://smj.im/blag/posts/cpp-inline-keyword/</link><guid isPermaLink="true">https://smj.im/blag/posts/cpp-inline-keyword/</guid><description>C++ inline关键字的学习笔记记录</description><pubDate>Sun, 22 Dec 2019 01:37:11 GMT</pubDate><content:encoded>&lt;p&gt;当程序执行函数调用指令时，CPU 将存储该函数调用后指令的内存地址，将函数的参数复制到堆栈上，最后将控制权转移到指定的函数。然后，CPU 执行函数代码，将函数返回值存储在预定义的内存位置/寄存器中，并将控制权返回给调用函数。如果函数的执行时间少于从调用者函数到被调用函数（被调用者）的切换时间，则这可能会成为开销。对于大型函数和/或执行复杂任务的函数，与函数运行所花费的时间相比，函数调用的开销通常微不足道。但是，对于小型的常用功能，进行函数调用所需的时间通常比实际执行函数代码所需的时间多得多。对于小功能，由于小功能的执行时间少于切换时间，因此会产生开销。&lt;/p&gt;
&lt;p&gt;C++提供了 inline 函数，以减少函数调用的开销。内联函数是在调用时在行中扩展的函数。调用内联函数时，将在内联函数调用时插入或替换内联函数的整个代码。替换由 C ++编译器在编译时执行。如果内联函数很小，则可以提高效率。&lt;/p&gt;
&lt;p&gt;inline 函数看起来像函数，动作像函数，但是又比宏方便很多，调用 inline 函数省去了参数压栈、生成汇编语言的 CALL 调用、返回参数、执行 return 等过程所花费的额外开销。不过 inline 函数也有缺点：增加目标码的大小。因为 inline 函数的设计思想是对该函数的所有调用都用函数本身替换掉，和宏定义一样，但是比宏定义用起来要简单很多。而且 inline 的调试同样很难。&lt;/p&gt;
&lt;p&gt;所以，inline 函数对于函数体积很小，却又频繁调用这样的函数来说，可能比函数调用产生的代码更少，但是效率却不可同日而语。有一点需要注意的是：**inline 只是对编译器提出一个申请，并不是强制命令。编译器可以忽略内联请求。**在以下情况下，编译器可能不会执行内联：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果函数包含循环。（对于 while，do-while）&lt;/li&gt;
&lt;li&gt;如果函数包含静态变量。&lt;/li&gt;
&lt;li&gt;如果函数是递归的。&lt;/li&gt;
&lt;li&gt;如果函数的返回类型不是 void，并且函数主体中不存在 return 语句。&lt;/li&gt;
&lt;li&gt;如果函数包含 switch 或 goto 语句。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;inline 可以显示声明，也可以隐式声明。隐式声明方式是将函数定义在类定义之中（函数定义时没有 inline 关键字），编译器也会当作 inline 函数。另外，定义在类中的 friend 函数也会被隐式声明为 inline 函数。&lt;/p&gt;
&lt;p&gt;显式声明的时候必须与函数定义体放在一起才能使函数成为内联，仅将 inline 放在函数声明前面不起任何作用。定义函数内联的语法为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    inline return-type function-name(parameters)
    {
        // function code
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;此外，inline 函数通常放在头文件中，因为大多数 build environments 在编译期进行 inlining，编译器必须知道函数什么样子才能把&lt;em&gt;函数调用&lt;/em&gt;替换成&lt;em&gt;函数本体。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;大多数 virtual 函数不能 inlining：因为 virtual 知道运行时才知道调用哪个函数，而 inline 是在执行前进行替换。此外，编译器通常不会 inlining**&lt;em&gt;通过函数指针进行的调用，&lt;/em&gt;**下面是一个实例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    inline void f() {...}      // assume compilers are willing to inline calls to f
    void (*pf)() = f;          // pf points to f
    ...
    f();                      // this call will be inlined, because it&apos;s a &quot;normal&quot; call
    pf();                     // this call probably won&apos;t be, because it&apos;s through              // a function pointer
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;内联函数的优点：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;不会发生函数调用开销。&lt;/li&gt;
&lt;li&gt;调用函数时，还节省了 push / pop 变量在栈上的开销。&lt;/li&gt;
&lt;li&gt;它还节省了从函数返回调用的开销。&lt;/li&gt;
&lt;li&gt;内联函数时，可以使编译器对函数主体执行特定于上下文的优化。对于正常的函数调用，这种优化是不可能的。通过考虑调用上下文和被调用上下文的流程可以获得其他优化。&lt;/li&gt;
&lt;li&gt;内联函数可能对于嵌入式系统有用（如果很小），因为内联函数所产生的代码少于函数调用的前导和返回。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;内联函数的缺点：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;内联函数中添加的变量消耗了额外的寄存器，在内联函数之后，如果要使用寄存器的变量编号增加，则它们可能会增加寄存器变量资源利用的开销。这意味着当在函数调用点替换内联函数主体时，该函数使用的变量总数也会被插入。因此，将用于变量的寄存器数量也将增加。因此，如果函数内联后的变量数急剧增加，则肯定会导致寄存器利用率增加。&lt;/li&gt;
&lt;li&gt;如果使用太多的内联函数，则由于重复执行相同的代码，二进制可执行文件的大小将很大。&lt;/li&gt;
&lt;li&gt;过多的内联也会降低指令 Cache 命中率，从而降低了从高速缓存到主存储器的指令获取速度。&lt;/li&gt;
&lt;li&gt;如果有人更改了内联函数中的代码，则内联函数可能会增加编译时间开销，然后必须重新编译所有调用位置，这是因为编译器将需要再次替换所有代码以反映更改，否则它将继续使用旧功能。&lt;/li&gt;
&lt;li&gt;内联函数对于许多嵌入式系统可能没有用。因为在嵌入式系统中，代码大小比速度更重要。&lt;/li&gt;
&lt;li&gt;内联函数可能会导致崩溃，因为内联可能会增加二进制可执行文件的大小。内存溢出会导致计算机性能下降。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将大多数内联限制在小的，经常调用的函数中。这有助于调试和二进制可升级性，最大程度地减少潜在的代码膨胀，并最大程度地提高程序速度。&lt;/li&gt;
&lt;li&gt;不要仅仅因为函数模板出现在头文件中就声明 inline。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Reference&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.amazon.com/Effective-Specific-Addison-Wesley-Professional-Computing/dp/0201924889&quot;&gt;Effective C++&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geeksforgeeks.org/inline-functions-cpp/&quot;&gt;https://www.geeksforgeeks.org/inline-functions-cpp/&lt;/a&gt;&lt;/p&gt;
</content:encoded></item><item><title>C++ Static关键字详解</title><link>https://smj.im/blag/posts/cpp-static-keyword/</link><guid isPermaLink="true">https://smj.im/blag/posts/cpp-static-keyword/</guid><pubDate>Sat, 21 Dec 2019 01:59:11 GMT</pubDate><content:encoded>&lt;p&gt;C++的 static 有两种用法：面向过程程序设计中的 static(延续 C 语言)和面向对象程序设计中的 static。&lt;/p&gt;
&lt;h2&gt;面向过程：&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;静态全局变量：
&lt;ul&gt;
&lt;li&gt;该变量在全局数据区分配内存；&lt;/li&gt;
&lt;li&gt;未经初始化的静态全局变量会被程序自动初始化为 0（自动变量的值是随机的，除非它被显式初始化）；&lt;/li&gt;
&lt;li&gt;静态全局变量在声明它的整个文件都是可见的，而在文件之外是不可见的；&lt;/li&gt;
&lt;li&gt;静态全局变量不能被其它文件所用；&lt;/li&gt;
&lt;li&gt;其它文件中可以定义相同名字的变量，不会发生冲突；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;静态局部变量：
&lt;ul&gt;
&lt;li&gt;该变量在全局数据区分配内存；&lt;/li&gt;
&lt;li&gt;静态局部变量在程序执行到该对象的声明处时被首次初始化，即以后的函数调用不再进行初始化；&lt;/li&gt;
&lt;li&gt;静态局部变量一般在声明处初始化，如果没有显式初始化，会被程序自动初始化为 0；&lt;/li&gt;
&lt;li&gt;它始终驻留在全局数据区，直到程序运行结束。但其作用域为局部作用域，当定义它的函数或语句块结束时，其作用域随之结束；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;静态函数：
&lt;ul&gt;
&lt;li&gt;在函数的返回类型前加上 static 关键字,函数即被定义为静态函数。静态函数与普通函数不同，它只能在声明它的文件当中可见，不能被其它文件使用。&lt;/li&gt;
&lt;li&gt;其它文件中可以定义相同名字的函数，不会发生冲突；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;面向对象&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;静态数据成员
&lt;ul&gt;
&lt;li&gt;对于非静态数据成员，每个类对象都有自己的拷贝。而静态数据成员被当作是类的成员。无论这个类的对象被定义了多少个，静态数据成员在程序中也只有一份拷贝，由该类型的所有对象共享访问。&lt;/li&gt;
&lt;li&gt;静态数据成员存储在全局数据区。静态数据成员定义时要分配空间，所以不能在类声明中定义。&lt;/li&gt;
&lt;li&gt;静态数据成员和普通数据成员一样遵从 public,protected,private 访问规则。&lt;/li&gt;
&lt;li&gt;静态数据成员在全局数据区分配内存，属于本类的所有对象共享，所以，它不属于特定的类对象，在没有产生类对象时其作用域就可见，即在没有产生类的实例时，我们就可以操作它。&lt;/li&gt;
&lt;li&gt;类的静态数据成员有两种访问形式:＜类对象名＞.＜静态数据成员名＞ 或 ＜类类型名＞::＜静态数据成员名＞&lt;/li&gt;
&lt;li&gt;静态数据成员初始化的格式为:＜数据类型＞＜类名＞::＜静态数据成员名＞=＜值＞&lt;/li&gt;
&lt;li&gt;静态数据成员主要用在各个对象都有相同的某项属性的时候。比如对于一个存款类，每个实例的利息都是相同的。所以，应该把利息设为存款类的静态数据成员。这有两个好处，第一，不管定义多少个存款类对象，利息数据成员都共享分配在全局数据区的内存，所以节省存储空间。第二，一旦利息需要改变时，只要改变一次，则所有存款类对象的利息全改变过来了;&lt;/li&gt;
&lt;li&gt;同全局变量相比，使用静态数据成员有两个优势:
&lt;ol&gt;
&lt;li&gt;静态数据成员没有进入程序的全局名字空间，因此不存在与程序中其它全局名字冲突的可能性;&lt;/li&gt;
&lt;li&gt;可以实现信息隐藏。静态数据成员可以是 private 成员，而全局变量不能;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;静态数据函数
&lt;ul&gt;
&lt;li&gt;类体外的函数定义不能指定关键字 static;&lt;/li&gt;
&lt;li&gt;静态成员之间可以相互访问，包括静态成员函数访问静态数据成员和访问静态成员函数;&lt;/li&gt;
&lt;li&gt;非静态成员函数可以任意地访问静态成员函数和静态数据成员;&lt;/li&gt;
&lt;li&gt;静态成员函数不能访问非静态成员函数和非静态数据成员;&lt;/li&gt;
&lt;li&gt;调用静态成员函数，可以用成员访问操作符(.)和(-&amp;gt;)为一个类的对象或指向类对象的指针调用静态成员函数，也可以直接使用如下格式:＜类名＞::＜静态成员函数名＞（＜参数表＞）调用类的静态成员函数;&lt;/li&gt;
&lt;li&gt;由于没有 this 指针的额外开销，因此静态成员函数与类的全局函数相比速度上会有少许的增长;&lt;/li&gt;
&lt;li&gt;静态成员函数可以继承和覆盖,但无法是虚函数&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;Rerference&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/beyondanytime/archive/2012/06/08/2542315.html&quot;&gt;https://www.cnblogs.com/beyondanytime/archive/2012/06/08/2542315.h&lt;/a&gt;&lt;/p&gt;
</content:encoded></item><item><title>Solution for _CRT_SECURE_NO_WARNINGS error</title><link>https://smj.im/blag/posts/solution-for-_crt_secure_no_warnings/</link><guid isPermaLink="true">https://smj.im/blag/posts/solution-for-_crt_secure_no_warnings/</guid><pubDate>Wed, 10 Jul 2019 13:45:00 GMT</pubDate><content:encoded>&lt;blockquote&gt;
&lt;p&gt;platform: VS2019
os: win10&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Problem:
An error about &lt;code&gt;_CRT_SECURE_NO_WARNINGS&lt;/code&gt; when I use the &lt;code&gt;std::localtime()&lt;/code&gt; function for getting the current systime.&lt;/p&gt;
&lt;p&gt;Solution:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Use an alternative feature function in C++.&lt;/li&gt;
&lt;li&gt;add this line at the first line.&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;#define _CRT_SECURE_NO_WARNINGS
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;add &lt;code&gt;_CRT_SECURE_NO_WARNINGS&lt;/code&gt; on the pre-processor(project&amp;gt;properties&amp;gt;C/C++&amp;gt;preprocessor)&lt;/li&gt;
&lt;/ol&gt;
</content:encoded></item><item><title>Customize Ubuntu themes, icons and Shell</title><link>https://smj.im/blag/posts/customize-ubuntu-themes/</link><guid isPermaLink="true">https://smj.im/blag/posts/customize-ubuntu-themes/</guid><pubDate>Fri, 07 Dec 2018 04:23:03 GMT</pubDate><content:encoded>&lt;h2&gt;Pre-requirements&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;gtk+3 &lt;a href=&quot;https://www.gtk.org/download/linux.php&quot;&gt;download&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;gnome-tweak-tool
&lt;code&gt;sudo apt-get update&lt;/code&gt; and &lt;code&gt;sudo apt-get gnome-tweak-tool&lt;/code&gt;
&lt;img src=&quot;https://pichost.netlify.app/blog/656037f2073ea.webp&quot; alt=&quot;Tweaks&quot; /&gt;&lt;/li&gt;
&lt;li&gt;Install an gnome shell Extension
&lt;code&gt;sudo apt-get install gnome-shell-extensions&lt;/code&gt;
&lt;strong&gt;Reboot after executing this command&lt;/strong&gt;
Then you can find a extensions named &lt;em&gt;user themes&lt;/em&gt;
Make it &lt;code&gt;on&lt;/code&gt;
&lt;img src=&quot;https://pichost.netlify.app/blog/65603a462d274.webp&quot; alt=&quot;extensions&quot; /&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;Start!&lt;/h2&gt;
&lt;h3&gt;Install an GTK+ themes&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;Download themes files from &lt;a href=&quot;https://www.opendesktop.org/s/Gnome/p/1241688&quot;&gt;here&lt;/a&gt;.
&lt;img src=&quot;https://pichost.netlify.app/blog/656038428f158.webp&quot; alt=&quot;test&quot; /&gt;&lt;/li&gt;
&lt;li&gt;Decompression files use these commands
&lt;code&gt;xz -d filename.tar.xz&lt;/code&gt;
&lt;code&gt;tar xvf filename.tar&lt;/code&gt;
then you can see a folder on current directiry&lt;/li&gt;
&lt;li&gt;Move the folder to &lt;em&gt;themes&lt;/em&gt; folder
&lt;code&gt;sudo mv filename /usr/share/themes&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Open Tweaks and change themes on &lt;em&gt;Appearence-&amp;gt;Themes-&amp;gt;Applications&lt;/em&gt;
&lt;img src=&quot;https://pichost.netlify.app/blog/65603a1d7daf2.webp&quot; alt=&quot;them-done&quot; /&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;Install macOS ICON&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;Download file from &lt;a href=&quot;https://www.opendesktop.org/s/Gnome/p/1102582/&quot;&gt;here&lt;/a&gt;
similar to install themes&lt;/li&gt;
&lt;li&gt;Decompression files and move it to &lt;em&gt;/home/baddate/.icons&lt;/em&gt;
&lt;strong&gt;maybe you should press ctrl + h to show hidden file, if it doesn&apos;t exists, you can new one folder named&lt;/strong&gt; &lt;code&gt;.icon&lt;/code&gt; &lt;strong&gt;then move the icons foder&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Go to Tweaks &lt;code&gt;Appearence&lt;/code&gt; window and select &lt;code&gt;icon&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;Install mac similar Shell&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;Download file from &lt;a href=&quot;https://www.opendesktop.org/s/Gnome/p/1013741/&quot;&gt;here&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Select &lt;code&gt;Sierra-compact-light.tar.xz&lt;/code&gt; or&lt;code&gt;Sierra-compact-dark.tar.xz&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Decompression it and move it to /usr/share/themes.&lt;/li&gt;
&lt;li&gt;Go to Tweaks &lt;code&gt;Appearence&lt;/code&gt; window and select &lt;code&gt;Shell&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;That&apos;s all.
Enjoy your Ubuntu-Mac!&lt;/p&gt;
</content:encoded></item><item><title>恢复右键菜单的新建命令</title><link>https://smj.im/blag/posts/recover-win10-new-command/</link><guid isPermaLink="true">https://smj.im/blag/posts/recover-win10-new-command/</guid><pubDate>Sun, 12 Aug 2018 10:07:23 GMT</pubDate><content:encoded>&lt;blockquote&gt;
&lt;p&gt;有的时候我们会发现自己常用的“新建”文件类型丢失了，这时候我们可以修改注册表来添加找回。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;假设丢失的是新建&lt;code&gt;.txt&lt;/code&gt; 文件类型&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;用记事本新建一个文本文件，命名为“ADDTXT.REG”&lt;/li&gt;
&lt;li&gt;输入以下代码：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;Windows Registry Editor Version 5.00
[HKEY_CLASSES_ROOT\.TXT\ShellNew]&quot;NullFile&quot;=&quot;&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;保存该文件并执行。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;REFERENCE：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;电脑爱好者2018-12&lt;/p&gt;
</content:encoded></item><item><title>Hugo+Github搭建个人博客</title><link>https://smj.im/blag/posts/build-site-with-hugo/</link><guid isPermaLink="true">https://smj.im/blag/posts/build-site-with-hugo/</guid><pubDate>Wed, 25 Jul 2018 12:13:00 GMT</pubDate><content:encoded>&lt;h2&gt;安装Git&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;在&lt;a href=&quot;https://git-scm.com/downloads&quot;&gt;这个页面&lt;/a&gt;下载最新版的Git。&lt;/li&gt;
&lt;li&gt;然后按照wizard指引安装Git。&lt;/li&gt;
&lt;li&gt;配置环境变量&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;graph LR
a[control panel] --&amp;gt; b[System and Security]
b[System and Security] --&amp;gt; c[System]
c[System] --&amp;gt; d[Advanced system settings]
d[Advanced system settings] --&amp;gt; e[ENvirment Variables..]
e[ENvirment Variables..] --&amp;gt; f[select Path then Edit]
f[select Path then Edit] --&amp;gt; g[add git path]
g[add git path] --&amp;gt; Done!
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;创建GitHub账号&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;这个自行&lt;a href=&quot;http://www.baidu.com/&quot;&gt;百度&lt;/a&gt; or &lt;a href=&quot;https://www.google.com/&quot;&gt;Google&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;安装Hugo&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;从&lt;a href=&quot;https://github.com/gohugoio/hugo/releases&quot;&gt;Hugo Releases&lt;/a&gt;下载Hugo压缩包(记得注意系统位数是32 or 64)&lt;/li&gt;
&lt;li&gt;解压压缩包&lt;/li&gt;
&lt;li&gt;配置环境变量(同上)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;当然还有其他方法，这边就暂时不介绍了，有兴趣的同学可以参考&lt;a href=&quot;https://gohugo.io/getting-started/installing/&quot;&gt;这里&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;配置Hugo&lt;/h2&gt;
&lt;h3&gt;创建网站&lt;/h3&gt;
&lt;p&gt;使用&lt;code&gt;hugo new site sitename&lt;/code&gt;命令来创建一个网站模板
模板包含下面这些文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    ├── archetypes
    ├── content
    ├── data
    ├── layouts
    ├── static
    ├── themes
    └── config.toml
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;安装主题&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;在这个&lt;a href=&quot;https://themes.gohugo.io/&quot;&gt;Hugo 主题&lt;/a&gt;页面找一个喜欢的主题下载并安装。&lt;/li&gt;
&lt;li&gt;下载的应该是一个压缩包，把它解压到&lt;code&gt;themes&lt;/code&gt;这个文件夹里面。&lt;/li&gt;
&lt;li&gt;接下来就是配置网站了，在上面我们可以发现有一个名为&lt;code&gt;config.toml&lt;/code&gt;的文件，所以我们只要编辑这个文件就可以配置我们的网站了。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;我们上面只是下载解压了那个主题文件夹，并没有把它加载到我们的创建的网站上，所以这个时候我们只要在&lt;code&gt;config.toml&lt;/code&gt;这个文件里添加一行&lt;code&gt;themes = &quot;theme_name&quot;&lt;/code&gt;就搞定了。
主题也安装好了，接下来就可以试试效果了：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;我们在&lt;code&gt;content&lt;/code&gt;文件夹里面新建一个文件夹，命名为&lt;code&gt;post&lt;/code&gt;(一定要是这个名字哦，这个是默认的，如果要用其他名字，还需要在*&lt;em&gt;config&lt;/em&gt;文件里面添加一行代码，这里暂时不做讨论了)&lt;/li&gt;
&lt;li&gt;在网站根目录(即: ./sitename下)打开命令行(&lt;code&gt;win&lt;/code&gt;+&lt;code&gt;R&lt;/code&gt;,然后输入&lt;code&gt;cmd&lt;/code&gt;), 输入&lt;code&gt;hugo server -t theme_name&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;我们打开(http://localhost:1313)就可以看到了! 这个时候我们会发现多了一个&lt;code&gt;public&lt;/code&gt;文件夹，这个文件夹包含了我们生成的网页内容
当然，这个时候才刚刚完成了一半，因为现在只有我们自己可以看到这个网页，别人是看不到的。所以，这个时候我们就要把它部署到服务器上了，服务器可以有好多选择，这里就只讨论Github pages了，毕竟是免费还不限流量的嘛！&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;在Github Pages上部署&lt;/h2&gt;
&lt;h3&gt;创建 GitHub pages&lt;/h3&gt;
&lt;p&gt;这个可以参考&lt;a href=&quot;https://pages.github.com/&quot;&gt;官方教程&lt;/a&gt;，就不赘述了，有疑问的同学可以私信我。&lt;/p&gt;
&lt;h3&gt;在Github上托管&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;在 GitHub 上创建 &lt;code&gt;your-project-name&lt;/code&gt; 代码仓库（它将用于托管 Hugo 的内容）&lt;/li&gt;
&lt;li&gt;在 GitHub 上创建 &lt;code&gt;username.github.io&lt;/code&gt; 代码仓库（它将用于托管 &lt;code&gt;public&lt;/code&gt; 文件夹：静态的网站）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git clone &amp;lt;your-project-name-url&amp;gt; &amp;amp;&amp;amp; cd &amp;lt;your-project-name&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;hugo new site sitename&lt;/code&gt;来创建网站，在&lt;code&gt;&amp;lt;your-project-name&amp;gt;&lt;/code&gt;目录下。&lt;/li&gt;
&lt;li&gt;让你的网站在本地生效，输入&lt;code&gt;hugo server -t theme_name&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;看到效果后，我们这时候需要把&lt;code&gt;public&lt;/code&gt;这个文件夹删除了&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git submodule add git@github.com:&amp;lt;username&amp;gt;/&amp;lt;username&amp;gt;.github.io.git public&lt;/code&gt; (这里又生成一个&lt;code&gt;public&lt;/code&gt;文件夹，这就是我们的网页文件)&lt;/li&gt;
&lt;li&gt;最后，我们添加一个脚本(deploy.sh)来帮我们简化操作&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;#!/bin/bash

echo -e &quot;\033[0;32mDeploying updates to GitHub...\033[0m&quot;

# Build the project.
hugo # if using a theme, replace by `hugo -t &amp;lt;yourtheme&amp;gt;`

# Go To Public folder
cd public
# Add changes to git.
git add -A

# Commit changes.
msg=&quot;rebuilding site `date`&quot;
if [ $# -eq 1 ]
  then msg=&quot;$1&quot;
fi
git commit -m &quot;$msg&quot;

# Push source and build repos.
git push origin master

# Come Back
cd ..
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;到这里我们的个人网站就建成了！！！&lt;/strong&gt; 让我们马上看看效果吧(http://username.github.io/), 可能会有些延迟哦，要有耐心。&lt;/p&gt;
</content:encoded></item></channel></rss>